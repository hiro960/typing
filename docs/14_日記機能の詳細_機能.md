# 日記機能 - 機能仕様

> **Note**: このドキュメントは日記機能の機能仕様を記載しています。
> データモデル設計は [DB設計](./14_日記機能の詳細_DB.md) を、
> API設計は [API設計](./14_日記機能の詳細_API.md) を、
> UI/UX設計は [UI/UX設計](./14_日記機能の詳細_UI.md) を参照してください。

---

## コンセプト
韓国語学習者が気軽に韓国語で日記を書き、他のユーザーと交流できるSNS型の機能。
X（旧Twitter）のような手軽さと、学習支援機能を組み合わせた、学習者に優しい設計。

## 投稿機能
### 投稿作成
- **最大文字数**: 280文字（X/Twitterと同様）

### 投稿の編集
- **編集可能期間**:
  - **公開済み投稿**（`visibility=public` または `followers`）: 投稿後24時間以内のみ編集可能
  - **下書き**（`visibility=private`）: 期限なし、いつでも編集可能
- **編集回数**: 制限なし
- **編集履歴**: 保存しない（最新の編集内容のみ保持）
- **編集マーク**: 編集された投稿には「(編集済み)」と最終編集日時を表示
- **API**: `PATCH /api/posts/{postId}`
- **編集可能内容**:
  - 本文テキスト
  - 画像の追加・削除（最大4枚まで）
  - ハッシュタグの変更
  - 公開範囲の変更
- **制限事項**:
  - 自分の投稿のみ編集可能
  - 公開済み投稿は編集期限（24時間）を過ぎると編集不可
  - 下書きには編集期限の制限なし

### 画像・メディア添付
- **画像**: 最大4枚まで添付可能
- **フォーマット**: JPEG、PNG のみ
- **圧縮**: 自動で最適化（アップロード時）
- **遅延読み込み**: `cached_network_image`を使用してパフォーマンス最適化

### ハッシュタグ
- **保存・通信形式**: `#`なしで統一（例: `["korean", "한국어"]`）
- **自動検出**: UI入力時に`#`で始まる単語を自動でハッシュタグとして認識
- **正規化ルール**:
  - `#`記号を削除して保存
  - 英語の場合は小文字に統一（例: `Korean` → `korean`）
  - 韓国語・日本語はそのまま保存（例: `한국어` → `한국어`）
  - 前後の空白を削除
  - 最大長: 40文字
- **UI表示**: フロントエンドで`#`を付けて表示（例: `korean` → `#korean`）
- **API送受信**: 常に`#`なしで送受信
- **互換性**: `POST`で`#`付きが来た場合、サーバー側で自動的に除去して処理

**ハッシュタグ正規化の実装例（バックエンド）**:
```typescript
function normalizeHashtag(tag: string): string {
  // #を削除（互換性のため、#付きでも受け入れる）
  let normalized = tag.replace(/^#/, '').trim()

  // 英語のみの場合は小文字化
  if (/^[a-zA-Z0-9_]+$/.test(normalized)) {
    normalized = normalized.toLowerCase()
  }

  return normalized
}

// POST /api/posts での使用例
const normalizedTags = body.tags.map(tag => normalizeHashtag(tag))

// 使用例
normalizeHashtag('Korean')       // => 'korean'
normalizeHashtag('#Korean')      // => 'korean' （互換性）
normalizeHashtag('한국어')        // => '한국어'
normalizeHashtag('#한국어')       // => '한국어' （互換性）
normalizeHashtag('Learning_Korean') // => 'learning_korean'
```

**クライアント側（Flutter）での処理**:
```dart
// UI表示時に#を付ける
String displayHashtag(String tag) => '#$tag';

// API送信時は#なしで送信
List<String> extractHashtags(String content) {
  final regex = RegExp(r'#(\S+)');
  final matches = regex.allMatches(content);
  return matches.map((m) => m.group(1)!).toList(); // #を除去
}
```

## フィード表示
### タイムライン種類
- **おすすめ** (`recommended`): アルゴリズムで選ばれた人気投稿（スコアベース）
- **フォロー中** (`following`): フォローしているユーザーの投稿
- **最新** (`latest`): 時系列で全ての投稿

### フィルタリング・検索
- **キーワード検索**: 全文検索機能、ハッシュタグ検索
- **ユーザー検索**: ユーザー名・表示名で検索

## インタラクション機能
### いいね（좋아요 / ♥）
- ワンタップでいいね
- いいねリストの表示
- いいね数によるトレンド判定

### コメント（댓글 / 💬）
- 投稿へのコメント機能
- **最大文字数**: 280文字（投稿と同じ）
- ネスト構造（返信の返信）には対応しない（シンプルさ優先）
- コメントにもいいね可能
- **削除権限**: コメント投稿者のみが削除可能（元の投稿作者でも他人のコメントは削除不可）

### リポスト（공유 / 🔁）
リポストには2種類があります：

#### 1. 通常のリポスト（シンプルなシェア）
- 他のユーザーの投稿を自分のフォロワーにシェア
- コメントなし、単純な共有
- `Repost` モデルで管理

#### 2. Quoteリポスト（引用リツイート / Quote Post）
- 元の投稿を引用しながら自分のコメントを追加
- **独立した投稿エンティティ**として扱う（`Post` モデルで管理）
- 通常の投稿と同様に、いいね・コメント・リポストが可能
- **コメント最大文字数**: 280文字（通常の投稿と同じ）
- 元の投稿へのリンク（`quotedPostId`）を持つ

### ブックマーク（북마크 / 🔖）
- お気に入りの投稿を保存
- プライベート機能（他のユーザーには見えない）

## ユーザープロフィール
### プロフィール情報
- 既存のprofile_screen.dartを使用

### フォロー機能
- **フォロー/フォロー解除**: ワンタップで切り替え
- **フォロワー一覧**: 自分をフォローしているユーザー
- **フォロー中一覧**: 自分がフォローしているユーザー

## 通知機能
### 通知種類
- 💬 **コメント**: 自分の投稿にコメントがついた
- ❤️ **いいね**: 自分の投稿にいいねがついた
- 🔁 **リポスト**: 自分の投稿がリポストされた
- 👥 **フォロー**: 新しいフォロワーが増えた

### 通知の重複防止ロジック

#### 基本方針
- **同一ユーザーから同一対象への同じタイプの通知は1つのみ**
- 重複を防ぐため、Notificationモデルにユニーク制約を設定
- いいね→取り消し→いいねのような短時間の繰り返しアクションでも通知が重複しない

#### 通知作成時のロジック

**1. いいね通知（`POST /api/posts/{postId}/like`）**:

```typescript
async function createLikeNotification(postId: string, actorId: string) {
  const post = await prisma.post.findUnique({ where: { id: postId } });

  // 自分の投稿にいいねした場合は通知を送信しない
  if (post.userId === actorId) return;

  // ユーザーの通知設定を確認
  const user = await prisma.user.findUnique({ where: { id: post.userId } });
  const settings = user.settings as any;
  if (settings?.notifications?.likes === false) return;

  // Upsert: 既存の通知があれば更新、なければ作成
  await prisma.notification.upsert({
    where: {
      userId_actorId_type_postId_commentId: {
        userId: post.userId,
        actorId: actorId,
        type: 'LIKE',
        postId: postId,
        commentId: null,
      },
    },
    update: {
      isRead: false,      // 未読に戻す
      createdAt: new Date(), // 最新の通知として扱う
    },
    create: {
      userId: post.userId,
      actorId: actorId,
      type: 'LIKE',
      postId: postId,
      isRead: false,
    },
  });
}
```

**2. いいね取り消し時（`DELETE /api/posts/{postId}/like`）**:

```typescript
async function removeLikeNotification(postId: string, actorId: string) {
  const post = await prisma.post.findUnique({ where: { id: postId } });

  // 未読の通知のみ削除
  await prisma.notification.deleteMany({
    where: {
      userId: post.userId,
      actorId: actorId,
      type: 'LIKE',
      postId: postId,
      commentId: null,
      isRead: false, // 未読の場合のみ削除
    },
  });

  // 既読の通知は履歴として残す
}
```

**3. コメント通知（`POST /api/posts/{postId}/comments`）**:

```typescript
async function createCommentNotification(postId: string, commentId: string, actorId: string) {
  const post = await prisma.post.findUnique({ where: { id: postId } });

  // 自分の投稿にコメントした場合は通知を送信しない
  if (post.userId === actorId) return;

  // ユーザーの通知設定を確認
  const user = await prisma.user.findUnique({ where: { id: post.userId } });
  const settings = user.settings as any;
  if (settings?.notifications?.comments === false) return;

  // コメント通知は常に新規作成（コメント削除しても通知は残る）
  await prisma.notification.create({
    data: {
      userId: post.userId,
      actorId: actorId,
      type: 'COMMENT',
      postId: postId,
      commentId: commentId,
      isRead: false,
    },
  });
}
```

**注意**: コメント通知はユニーク制約の対象外（同じユーザーが複数回コメントする可能性があるため）

**4. フォロー通知（`POST /api/follows`）**:

```typescript
async function createFollowNotification(followingId: string, followerId: string) {
  // ユーザーの通知設定を確認
  const user = await prisma.user.findUnique({ where: { id: followingId } });
  const settings = user.settings as any;
  if (settings?.notifications?.follows === false) return;

  // Upsert: 既存の通知があれば更新、なければ作成
  await prisma.notification.upsert({
    where: {
      userId_actorId_type_postId_commentId: {
        userId: followingId,
        actorId: followerId,
        type: 'FOLLOW',
        postId: null,
        commentId: null,
      },
    },
    update: {
      isRead: false,      // 未読に戻す
      createdAt: new Date(), // 最新の通知として扱う
    },
    create: {
      userId: followingId,
      actorId: followerId,
      type: 'FOLLOW',
      isRead: false,
    },
  });
}
```

#### 通知の動作パターン

| シナリオ | 動作 |
|---------|------|
| ユーザーAが投稿Bにいいね | 通知を新規作成 |
| ユーザーAがいいねを取り消し（未読通知） | 通知を削除 |
| ユーザーAがいいねを取り消し（既読通知） | 通知を残す（履歴として） |
| ユーザーAが再度いいね（未読通知削除済み） | 通知を新規作成 |
| ユーザーAが再度いいね（既読通知あり） | 既存の通知を更新（未読に戻す） |
| ユーザーAが同じ投稿に複数回コメント | 各コメントごとに通知を作成 |

#### 通知の削除タイミング

**自動削除される場合**:
- いいね取り消し時（未読通知のみ）
- リポスト取り消し時（未読通知のみ）
- 投稿削除時（CASCADE削除）
- コメント削除時（CASCADE削除）
- フォロー解除時（未読通知のみ）

**自動削除されない場合**:
- 既読の通知（履歴として保持）
- コメント通知（コメント削除時も通知は残る）

#### 通知設定との連携

- 通知送信前に必ずユーザーの通知設定（`User.settings.notifications`）を確認
- 設定がOFFの場合は通知を作成しない
- プッシュ通知も同様に設定を確認

#### 将来の拡張（Phase 5 以降）

**集約通知**:
- 「@user1と他3人があなたの投稿にいいねしました」
- 実装方法: 複数のいいね通知をグルーピングして表示
- データモデルは変更せず、UI層で集約処理を実装

### 通知設定

#### 設定項目
- **いいね通知** (`likes`): 自分の投稿にいいねがついた時
- **コメント通知** (`comments`): 自分の投稿にコメントがついた時
- **リポスト通知** (`reposts`): 自分の投稿がリポストされた時
- **フォロー通知** (`follows`): 新しいフォロワーが増えた時

#### UI操作
- **操作画面**: `setting_screen.dart` の通知設定セクション
- 各項目にトグルスイッチを配置
- 設定変更は即座にサーバーに反映

#### API仕様
詳細なAPI仕様は [API設計](./14_日記機能の詳細_API.md#get-apiusersme-settings) を参照してください。

**実装詳細**:
- 設定は `User.settings` JSONフィールドに保存
- 通知送信時に設定をチェックし、OFFの場合は通知を送信しない
- デフォルト値: すべて`true`（通知ON）

**Flutter実装例**:
```dart
// 設定取得
final settings = await apiClient.getUserSettings();

// 設定更新
await apiClient.updateUserSettings(
  notifications: {
    'likes': true,
    'comments': false,
    'reposts': true,
    'follows': false,
  },
);
```

## モデレーション・安全機能
### 不適切コンテンツ対策
- **報告機能**: 不適切な投稿・コメント・ユーザーを報告
- **ブロック機能**: 特定ユーザーをブロック

### APIレート制限（スパム防止）
APIエンドポイントごとにレート制限を設定し、スパム行為を防止します。

**レート制限の設定**:
- **投稿作成**: `POST /api/posts`
  - 1分間に最大 **3回**
  - 1時間に最大 **20回**
- **コメント投稿**: `POST /api/posts/{postId}/comments`
  - 1分間に最大 **10回**
  - 1時間に最大 **50回**
- **いいね**: `POST /api/posts/{postId}/like`
  - 1分間に最大 **30回**
  - 1時間に最大 **200回**
- **フォロー**: `POST /api/follows`
  - 1分間に最大 **5回**
  - 1時間に最大 **30回**
- **画像アップロード**: `POST /api/upload/image`
  - 1分間に最大 **10枚**
  - 1時間に最大 **50枚**

**実装方法**:
```typescript
// Vercel KVを使用したレート制限
import { Ratelimit } from '@upstash/ratelimit'
import { kv } from '@vercel/kv'

const ratelimit = new Ratelimit({
  redis: kv,
  limiter: Ratelimit.slidingWindow(3, '1 m'), // 1分間に3回
})

// API Routeで使用
export async function POST(request: NextRequest) {
  const user = await requireAuthUser(request)

  // レート制限チェック
  const { success, limit, remaining, reset } = await ratelimit.limit(
    `post_create_${user.id}`
  )

  if (!success) {
    return NextResponse.json(
      { error: 'Rate limit exceeded. Please try again later.' },
      {
        status: 429,
        headers: {
          'X-RateLimit-Limit': limit.toString(),
          'X-RateLimit-Remaining': remaining.toString(),
          'X-RateLimit-Reset': reset.toString(),
        },
      }
    )
  }

  // 通常の処理...
}
```

**使用ライブラリ**:
- `@upstash/ratelimit` - レート制限ライブラリ
- `@vercel/kv` - Vercel KV (Redis互換のKey-Valueストア)

**エラーレスポンス**:
- ステータスコード: `429 Too Many Requests`
- ヘッダー:
  - `X-RateLimit-Limit`: 制限値
  - `X-RateLimit-Remaining`: 残り回数
  - `X-RateLimit-Reset`: リセット時刻（Unixタイムスタンプ）

**フロントエンドでの対応**:
- 429エラーを検知して、ユーザーにわかりやすいメッセージを表示
- リトライまでの待機時間を表示
- ボタンを一時的に無効化

## プライバシー設定

### 投稿の公開範囲
- **`public`（全体公開）**: デフォルト。すべてのユーザーが閲覧可能
- **`followers`（フォロワーのみ）**: 投稿者のフォロワーと本人のみ閲覧可能
- **`private`（下書き / 自分のみ）**: 投稿者本人のみ閲覧可能

### アクセス制御の統一方針

**タイムライン・検索結果（`GET /api/posts`, `GET /api/search`）**:
- 閲覧権限のない投稿は結果から**除外**（403や404は返さない）
- フィルタリング条件:
  1. `visibility=public` の投稿は全て含む
  2. `visibility=followers` の投稿は、閲覧者が投稿者のフォロワーまたは本人の場合のみ含む
  3. `visibility=private` の投稿は含めない（本人が明示的に取得する場合を除く）
  4. ブロック関係にあるユーザーの投稿は除外

**単体取得（`GET /api/posts/{postId}`）**:
- 閲覧権限がない場合は **404 Not Found** を返却（投稿の存在を隠蔽）
- アクセス可否の判定:
  1. `visibility=public` の投稿は誰でもアクセス可能
  2. `visibility=followers` の投稿は、閲覧者が投稿者のフォロワーまたは本人の場合のみアクセス可能
  3. `visibility=private` の投稿は、投稿者本人のみアクセス可能
  4. ブロック関係がある場合はアクセス不可

**通知・ブックマーク（`GET /api/notifications`, `GET /api/bookmarks`）**:
- 削除済み投稿やブロック関係の投稿は結果から除外
- `visibility=followers` の投稿で、閲覧者がフォロワーでなくなった場合も除外

### 下書き（`visibility=private`）の詳細仕様

#### 下書きの制限
- **サーバー側下書き**: 最大保存数制限なし（無制限）
- **保存期限**: 無制限（削除しない限り永続的に保存）
- **ローカル下書き**（オフライン時）:
  - 最大保存数: **制限なし**
  - 保存期限: アプリデータ削除まで永続的に保存
  - 保存先: `SharedPreferences` または `Hive`

**注意**: 初期実装では下書き数の制限は設けません。将来的にストレージ圧迫が問題になった場合は、ユーザーあたり最大100件などの制限を検討します。

#### 下書きの動作
1. **作成・保存**:
   - `POST /api/posts` で `visibility=private` を指定して作成
   - `postsCount` には**カウントしない**（公開時にカウント）
   - 通知は送信しない

2. **取得**:
   - 通常のタイムライン（`GET /api/posts`）には**含まれない**
   - 下書き一覧取得: `GET /api/posts?visibility=private`（本人のみアクセス可能）
   - 検索結果にも**含まれない**
   - ハッシュタグ検索にも**含まれない**

3. **編集**:
   - `PATCH /api/posts/{postId}` で編集可能
   - 編集期限（24時間）の制限は**適用されない**（下書きはいつでも編集可能）

4. **公開への切り替え**:
   - `PATCH /api/posts/{postId}` で `visibility` を `public` または `followers` に変更
   - 初回公開時の処理:
     - `createdAt` を現在時刻に更新（タイムライン順序の整合性と編集制限のため）
     - `User.postsCount` をインクリメント
     - フォロワーへの通知は**送信しない**（通知は「いいね」「コメント」等のアクション時のみ）
   - **理由**:
     - 下書き作成から時間が経過している場合、編集制限（24時間）が正しく機能しなくなる
     - タイムラインでの投稿順序が不自然になる（古い日付で新規投稿が表示される）

5. **削除**:
   - `DELETE /api/posts/{postId}` で削除可能
   - `postsCount` への影響なし（元々カウントされていないため）

#### 下書きのアクセス制御
- 他のユーザーが下書きの`postId`を知っていても、アクセスは**403 Forbidden**
- APIレスポンスで下書きが誤って含まれないよう、全エンドポイントで `visibility` チェックを実施

#### UI表示
- 下書き一覧画面を別途用意（`/drafts` または設定画面内）
- 投稿作成画面で「下書きとして保存」ボタンを用意

### プロフィールの公開範囲
- **全体公開**: デフォルト。すべてのユーザーが閲覧可能
- **フォロワーのみ閲覧可能**: フォロワー以外は基本情報のみ表示（投稿数、フォロー数は非表示）

## オフライン対応
- **下書き保存**: オフライン時に投稿を下書きとして保存
- **キャッシュ**: 過去の投稿をキャッシュして表示
- **同期**: オンライン復帰時に自動で下書きをアップロード

## 将来の拡張機能案

- 入力支援
  - (将来追加)リアルタイム文法チェック
  - (将来追加)（日本語→韓国語の簡易変換）

- 自動フィルタリング
  - (将来追加)スパム検出
  - (将来追加)不適切な言葉の自動検知
  - (将来追加)連続投稿の制限（スパム防止）

---

## 技術実装詳細

### 技術スタック

#### Backend
- **Framework**: Next.js 16 (App Router) + TypeScript
- **Database**: PostgreSQL (Vercel Neon) + Prisma ORM
- **Auth**: Auth0 (JWT)
- **Storage**: Vercel Blob Storage（画像保存）
- **Cache/Rate Limiting**: Vercel KV (Redis互換)
- **Push Notification**: Firebase Cloud Messaging (FCM)
- **Image Processing**: sharp
- **Rate Limiting**: @upstash/ratelimit

#### Frontend (Flutter)
- **State Management**: Riverpod 3.0
- **HTTP Client**: dio
- **Image Picker**: image_picker
- **Cache**:
  - flutter_cache_manager（画像キャッシュ）
  - cached_network_image（画像遅延読み込み）
- **Infinite Scroll**: infinite_scroll_pagination
- **Push Notification**: firebase_messaging
