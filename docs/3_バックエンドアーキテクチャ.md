# バックエンドアーキテクチャ

## プロジェクト構成
```
korean-typing-app/
├── frontend/                    # Flutterアプリ
│   ├── lib/
│   ├── pubspec.yaml
│   └── ...
├── backend/                     # Next.jsバックエンド（App Router）
│   ├── app/
│   │   ├── api/                 # Route Handlers
│   │   │   ├── users/
│   │   │   │   ├── route.ts
│   │   │   │   └── [id]/route.ts
│   │   │   ├── posts/
│   │   │   │   ├── route.ts
│   │   │   │   ├── [id]/route.ts
│   │   │   │   └── create/route.ts
│   │   │   ├── lessons/
│   │   │   │   ├── route.ts
│   │   │   │   └── complete/route.ts
│   │   │   └── health/route.ts
│   │   └── page.tsx             # ヘルスチェック用（オプション）
│   ├── prisma/
│   │   ├── schema.prisma
│   │   └── migrations/
│   ├── lib/
│   │   ├── prisma.ts            # Prismaクライアント
│   │   ├── jwt.ts               # JWT検証ヘルパー
│   │   └── utils.ts
│   ├── middleware.ts            # JWT検証ミドルウェア
│   ├── next.config.js
│   ├── package.json
│   └── tsconfig.json
└── docs/                        # ドキュメント
```

## API Routes構成
### ユーザー (/api/users)
- `GET /api/users` - ユーザー一覧取得（検索）
- `GET /api/users/[id]` - ユーザー詳細取得
- `PUT /api/users/[id]` - ユーザー情報更新
- `DELETE /api/users/[id]` - ユーザー削除
- `GET /api/users/[id]/posts` - ユーザーの投稿一覧
- `GET /api/users/[id]/stats` - ユーザーの統計情報

### 投稿 (/api/posts)
- `GET /api/posts` - 投稿一覧取得（フィード）
- `POST /api/posts` - 新規投稿作成
- `GET /api/posts/[id]` - 投稿詳細取得
- `PUT /api/posts/[id]` - 投稿更新
- `DELETE /api/posts/[id]` - 投稿削除
- `POST /api/posts/[id]/like` - いいね追加
- `DELETE /api/posts/[id]/like` - いいね削除
- `GET /api/posts/[id]/comments` - コメント一覧取得
- `POST /api/posts/[id]/comments` - コメント追加

### レッスン (/api/lessons)
- `GET /api/lessons` - レッスン一覧取得
- `GET /api/lessons/[id]` - レッスン詳細取得
- `POST /api/lessons/complete` - レッスン完了記録
- `GET /api/lessons/stats` - 学習統計取得

### フォロー (/api/follows)
- `POST /api/follows` - フォローする
- `DELETE /api/follows/[id]` - フォロー解除
- `GET /api/follows/followers` - フォロワー一覧
- `GET /api/follows/following` - フォロー中一覧

## ミドルウェア
### 認証ミドルウェア（JWT検証）
モバイルアプリから送信されるBearerトークンを検証します。

```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { jwtVerify } from 'jose';

export async function middleware(request: NextRequest) {
  const authHeader = request.headers.get('authorization');

  if (!authHeader?.startsWith('Bearer ')) {
    return NextResponse.json(
      { error: { code: 'UNAUTHORIZED', message: 'Missing or invalid authorization header' } },
      { status: 401 }
    );
  }

  const token = authHeader.substring(7);

  try {
    // Auth0のJWKSでトークンを検証
    const jwksUrl = new URL(`${process.env.AUTH0_ISSUER_BASE_URL}/.well-known/jwks.json`);
    const { payload } = await jwtVerify(token, jwksUrl, {
      issuer: process.env.AUTH0_ISSUER_BASE_URL,
      audience: process.env.AUTH0_AUDIENCE,
    });

    // 検証済みのユーザーIDをヘッダーに追加
    const requestHeaders = new Headers(request.headers);
    requestHeaders.set('x-user-id', payload.sub as string);

    return NextResponse.next({
      request: {
        headers: requestHeaders,
      },
    });
  } catch (error) {
    console.error('JWT verification failed:', error);
    return NextResponse.json(
      { error: { code: 'TOKEN_INVALID', message: 'Invalid or expired token' } },
      { status: 401 }
    );
  }
}

export const config = {
  matcher: ['/api/posts/:path*', '/api/users/:path*', '/api/lessons/:path*', '/api/follows/:path*'],
};
```

### レート制限
```typescript
// lib/rate-limit.ts
import { Redis } from '@upstash/redis';

const redis = Redis.fromEnv();

export async function rateLimit(
  identifier: string,
  limit: number,
  window: number
) {
  const key = `rate-limit:${identifier}`;
  const count = await redis.incr(key);

  if (count === 1) {
    await redis.expire(key, window);
  }

  return count <= limit;
}
```

### エラーハンドリング
```typescript
// lib/error-handler.ts
import { NextApiResponse } from 'next';

export class ApiError extends Error {
  constructor(
    public statusCode: number,
    public message: string
  ) {
    super(message);
  }
}

export function handleError(error: unknown, res: NextApiResponse) {
  if (error instanceof ApiError) {
    return res.status(error.statusCode).json({
      error: error.message,
    });
  }

  console.error('Unexpected error:', error);
  return res.status(500).json({
    error: 'Internal server error',
  });
}
```

## データベース設計（Prisma Schema）
```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                      String    @id @default(cuid())
  auth0UserId             String    @unique
  username                String    @unique
  displayName             String
  email                   String    @unique
  profileImageUrl         String?
  bio                     String?
  learningLevel           String    @default("beginner")
  totalLessonsCompleted   Int       @default(0)
  totalPracticeTime       Int       @default(0)
  maxWPM                  Int       @default(0)
  maxAccuracy             Float     @default(0)
  followersCount          Int       @default(0)
  followingCount          Int       @default(0)
  postsCount              Int       @default(0)
  settings                Json?     // ユーザー設定（通知、表示、タイピング、プライバシー）
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt
  lastLoginAt             DateTime?
  isActive                Boolean   @default(true)
  isBanned                Boolean   @default(false)

  posts                   Post[]
  comments                Comment[]
  likes                   Like[]
  following               Follow[]  @relation("Following")
  followers               Follow[]  @relation("Followers")
  lessonCompletions       LessonCompletion[]

  @@index([username])
  @@index([email])
  @@index([auth0UserId])
}

model Post {
  id          String    @id @default(cuid())
  content     String
  imageUrls   String[]
  visibility  String    @default("public")
  userId      String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  likesCount  Int       @default(0)
  commentsCount Int     @default(0)

  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  comments    Comment[]
  likes       Like[]

  @@index([userId])
  @@index([createdAt])
}

model Comment {
  id        String   @id @default(cuid())
  content   String
  postId    String
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([postId])
  @@index([userId])
}

model Like {
  id        String   @id @default(cuid())
  postId    String
  userId    String
  createdAt DateTime @default(now())

  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@index([userId])
}

model Follow {
  id          String   @id @default(cuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())

  follower    User     @relation("Following", fields: [followerId], references: [id], onDelete: Cascade)
  following   User     @relation("Followers", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
}

model Lesson {
  id          String   @id @default(cuid())
  title       String
  description String?
  level       String
  order       Int
  content     Json
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  completions LessonCompletion[]

  @@index([level])
  @@index([order])
}

model LessonCompletion {
  id          String   @id @default(cuid())
  lessonId    String
  userId      String
  wpm         Int
  accuracy    Float
  timeSpent   Int
  completedAt DateTime @default(now())

  lesson      Lesson   @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([lessonId])
  @@index([userId])
  @@index([completedAt])
}
```

## ユーザー設定型定義（TypeScript）
```typescript
// UserのsettingsフィールドのJSON型定義
interface UserSettings {
  // 通知設定
  notifications: {
    push: boolean;
    email: boolean;
    comment: boolean;
    like: boolean;
    follow: boolean;
  };

  // 表示設定
  theme: 'light' | 'dark' | 'auto';
  fontSize: 'small' | 'medium' | 'large';
  language: 'ja' | 'ko' | 'en';

  // タイピング設定
  soundEnabled: boolean;
  hapticEnabled: boolean;
  strictMode: boolean;  // 厳密モード（完全一致のみ）

  // プライバシー設定
  profileVisibility: 'public' | 'followers';
  postDefaultVisibility: 'public' | 'followers' | 'private';
}

// デフォルト設定値
const defaultUserSettings: UserSettings = {
  notifications: {
    push: true,
    email: true,
    comment: true,
    like: true,
    follow: true,
  },
  theme: 'auto',
  fontSize: 'medium',
  language: 'ja',
  soundEnabled: true,
  hapticEnabled: true,
  strictMode: true,
  profileVisibility: 'public',
  postDefaultVisibility: 'public',
};
```

## 環境変数（.env.local）
```bash
# Database
DATABASE_URL="postgresql://user:password@host:5432/dbname"

# Auth0（JWT検証用）
AUTH0_ISSUER_BASE_URL="https://your-tenant-region.auth0.com"
AUTH0_AUDIENCE="https://api.korean-typing.app"           # API識別子
AUTH0_MANAGEMENT_CLIENT_ID="your-management-client-id"   # Management API用
AUTH0_MANAGEMENT_CLIENT_SECRET="your-management-client-secret"

# Vercel Blob
BLOB_READ_WRITE_TOKEN="your-blob-token"

# Redis (Upstash)
UPSTASH_REDIS_REST_URL="your-redis-url"
UPSTASH_REDIS_REST_TOKEN="your-redis-token"

# Pusher
PUSHER_APP_ID="your-pusher-app-id"
PUSHER_KEY="your-pusher-key"
PUSHER_SECRET="your-pusher-secret"
PUSHER_CLUSTER="ap3"

# Sentry (オプション)
SENTRY_DSN="your-sentry-dsn"
```

**注意**: モバイルアプリ向けのため、Web版の認証に必要な `AUTH0_SECRET`, `AUTH0_BASE_URL`, `AUTH0_CLIENT_ID`, `AUTH0_CLIENT_SECRET` は不要です。JWT検証に必要な `AUTH0_ISSUER_BASE_URL` と `AUTH0_AUDIENCE` のみを設定します。
