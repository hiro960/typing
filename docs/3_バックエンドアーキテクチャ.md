# バックエンドアーキテクチャ

**認証フローとJWT検証の詳細は [docs/8_認証フロー詳細.md](./8_認証フロー詳細.md) を参照してください。**

## プロジェクト構成
```
korean-typing-app/
├── frontend/                    # Flutterアプリ
│   ├── lib/
│   ├── pubspec.yaml
│   └── ...
├── backend/                     # Next.jsバックエンド（App Router）
│   ├── app/
│   │   ├── api/                 # Route Handlers
│   │   │   ├── users/
│   │   │   │   ├── route.ts
│   │   │   │   └── [id]/route.ts
│   │   │   ├── posts/
│   │   │   │   ├── route.ts
│   │   │   │   ├── [id]/route.ts
│   │   │   │   └── create/route.ts
│   │   │   ├── lessons/
│   │   │   │   ├── route.ts
│   │   │   │   └── complete/route.ts
│   │   │   └── health/route.ts
│   │   └── page.tsx             # ヘルスチェック用（オプション）
│   ├── prisma/
│   │   ├── schema.prisma
│   │   └── migrations/
│   ├── lib/
│   │   ├── prisma.ts            # Prismaクライアント
│   │   ├── jwt.ts               # JWT検証ヘルパー
│   │   └── utils.ts
│   ├── middleware.ts            # JWT検証ミドルウェア
│   ├── next.config.js
│   ├── package.json
│   └── tsconfig.json
└── docs/                        # ドキュメント
```

## API Routes構成
### ユーザー (/api/users)
- `GET /api/users` - ユーザー一覧取得（検索）
- `GET /api/users/me` - 現在のユーザー情報取得
- `GET /api/users/status` - 現在のユーザーの登録状況確認
- `GET /api/users/check-username` - Username可用性チェック（リアルタイムバリデーション用）
- `POST /api/users/setup` - 初回ユーザー登録（Auth0認証後）
- `GET /api/users/[id]` - ユーザー詳細取得
- `PUT /api/users/[id]` - ユーザー情報更新
- `DELETE /api/users/[id]` - ユーザー削除
- `GET /api/users/[id]/posts` - ユーザーの投稿一覧
- `GET /api/users/[id]/stats` - ユーザーの統計情報

### 投稿 (/api/posts)
- `GET /api/posts` - 投稿一覧取得（フィード）
- `POST /api/posts` - 新規投稿作成
- `GET /api/posts/[id]` - 投稿詳細取得
- `PUT /api/posts/[id]` - 投稿更新
- `DELETE /api/posts/[id]` - 投稿削除
- `POST /api/posts/[id]/like` - いいね追加
- `DELETE /api/posts/[id]/like` - いいね削除
- `GET /api/posts/[id]/comments` - コメント一覧取得
- `POST /api/posts/[id]/comments` - コメント追加

### レッスン (/api/lessons)
- `GET /api/lessons` - レッスン一覧取得
- `GET /api/lessons/[id]` - レッスン詳細取得
- `POST /api/lessons/complete` - レッスン完了記録
- `GET /api/lessons/stats` - 学習統計取得

### フォロー (/api/follows)
- `POST /api/follows` - フォローする
- `DELETE /api/follows/[id]` - フォロー解除
- `GET /api/follows/followers` - フォロワー一覧
- `GET /api/follows/following` - フォロー中一覧

## 認証（JWT検証）

### 実装方針
本アプリケーションでは、Next.jsのグローバルミドルウェア（`middleware.ts`）は使用せず、各エンドポイント内で認証チェックを行う設計を採用しています。これにより、エンドポイントごとに柔軟な認証要件を設定できます。

### 認証ヘルパー関数（lib/auth.ts）
```typescript
// lib/auth.ts
import { NextRequest } from 'next/server';
import { jwtVerify, createRemoteJWKSet } from 'jose';
import { UNAUTHORIZED } from './errors';
import { findUserByAuth0Id } from './store';
import type { UserDetail } from './types';

// Auth0のJWKSエンドポイント（公開鍵取得用）
const JWKS = createRemoteJWKSet(
  new URL(`${process.env.AUTH0_ISSUER_BASE_URL}/.well-known/jwks.json`)
);

/**
 * Auth0のJWTトークンを検証してペイロードを取得
 */
async function verifyAuth0Token(request: NextRequest) {
  const authHeader = request.headers.get('authorization');

  if (!authHeader?.startsWith('Bearer ')) {
    throw UNAUTHORIZED('Missing or invalid authorization header');
  }

  const token = authHeader.substring(7);

  try {
    const { payload } = await jwtVerify(token, JWKS, {
      issuer: process.env.AUTH0_ISSUER_BASE_URL,
      audience: process.env.AUTH0_AUDIENCE,
    });

    return payload;
  } catch (error) {
    console.error('JWT verification failed:', error);
    throw UNAUTHORIZED('Invalid or expired token');
  }
}

/**
 * 認証必須のエンドポイントで使用
 * DBに登録済みのユーザーを返す
 */
export async function requireAuthUser(request: NextRequest): Promise<UserDetail> {
  const payload = await verifyAuth0Token(request);
  const auth0UserId = payload.sub as string;

  const user = await findUserByAuth0Id(auth0UserId);
  if (!user) {
    throw UNAUTHORIZED('User not registered. Please complete setup.');
  }

  return user;
}

/**
 * 認証オプショナルのエンドポイントで使用
 * トークンが有効でもDBに未登録の場合はnullを返す
 */
export async function getAuthUser(request: NextRequest): Promise<UserDetail | null> {
  try {
    return await requireAuthUser(request);
  } catch {
    return null;
  }
}

/**
 * Auth0ペイロードのみ取得（初回登録用）
 * DBに未登録でもエラーを出さない
 */
export async function getAuth0Payload(request: NextRequest) {
  return await verifyAuth0Token(request);
}

/**
 * ユーザーIDの権限チェック
 */
export function assertSameUser(userId: string, targetUserId: string): void {
  if (userId !== targetUserId) {
    throw FORBIDDEN('You can only modify your own data');
  }
}
```

### 使用例

#### パターン1: 認証必須（登録済みユーザーのみ）
```typescript
// app/api/posts/route.ts
export async function POST(request: NextRequest) {
  const user = await requireAuthUser(request); // 未登録の場合はエラー
  // ...
}
```

#### パターン2: 認証オプショナル
```typescript
// app/api/users/route.ts
export async function GET(request: NextRequest) {
  const user = await getAuthUser(request); // 未認証の場合はnull
  // ...
}
```

#### パターン3: 初回登録（Auth0認証のみ必要）
```typescript
// app/api/users/setup/route.ts
export async function POST(request: NextRequest) {
  const payload = await getAuth0Payload(request); // DBチェックなし
  const auth0UserId = payload.sub as string;
  const email = payload.email as string;
  // ...
}
```

### レート制限
```typescript
// lib/rate-limit.ts
import { Redis } from '@upstash/redis';

const redis = Redis.fromEnv();

export async function rateLimit(
  identifier: string,
  limit: number,
  window: number
) {
  const key = `rate-limit:${identifier}`;
  const count = await redis.incr(key);

  if (count === 1) {
    await redis.expire(key, window);
  }

  return count <= limit;
}
```

### エラーハンドリング
```typescript
// lib/error-handler.ts
import { NextApiResponse } from 'next';

export class ApiError extends Error {
  constructor(
    public statusCode: number,
    public message: string
  ) {
    super(message);
  }
}

export function handleError(error: unknown, res: NextApiResponse) {
  if (error instanceof ApiError) {
    return res.status(error.statusCode).json({
      error: error.message,
    });
  }

  console.error('Unexpected error:', error);
  return res.status(500).json({
    error: 'Internal server error',
  });
}
```

## データベース設計（Prisma Schema）
```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                      String    @id @default(cuid())
  auth0UserId             String    @unique
  username                String    @unique
  displayName             String
  email                   String    @unique
  profileImageUrl         String?
  bio                     String?
  learningLevel           String    @default("beginner")
  totalLessonsCompleted   Int       @default(0)
  totalPracticeTime       Int       @default(0)
  maxWPM                  Int       @default(0)
  maxAccuracy             Float     @default(0)
  followersCount          Int       @default(0)
  followingCount          Int       @default(0)
  postsCount              Int       @default(0)
  settings                Json?     // ユーザー設定（通知、表示、タイピング、プライバシー）
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt
  lastLoginAt             DateTime?
  isActive                Boolean   @default(true)
  isBanned                Boolean   @default(false)

  posts                   Post[]
  comments                Comment[]
  likes                   Like[]
  following               Follow[]  @relation("Following")
  followers               Follow[]  @relation("Followers")
  lessonCompletions       LessonCompletion[]

  @@index([username])
  @@index([email])
  @@index([auth0UserId])
}

model Post {
  id          String    @id @default(cuid())
  content     String
  imageUrls   String[]
  visibility  String    @default("public")
  userId      String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  likesCount  Int       @default(0)
  commentsCount Int     @default(0)

  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  comments    Comment[]
  likes       Like[]

  @@index([userId])
  @@index([createdAt])
}

model Comment {
  id        String   @id @default(cuid())
  content   String
  postId    String
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([postId])
  @@index([userId])
}

model Like {
  id        String   @id @default(cuid())
  postId    String
  userId    String
  createdAt DateTime @default(now())

  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@index([userId])
}

model Follow {
  id          String   @id @default(cuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())

  follower    User     @relation("Following", fields: [followerId], references: [id], onDelete: Cascade)
  following   User     @relation("Followers", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
}

model Lesson {
  id          String   @id @default(cuid())
  title       String
  description String?
  level       String
  order       Int
  content     Json
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  completions LessonCompletion[]

  @@index([level])
  @@index([order])
}

model LessonCompletion {
  id          String   @id @default(cuid())
  lessonId    String
  userId      String
  wpm         Int
  accuracy    Float
  timeSpent   Int
  completedAt DateTime @default(now())

  lesson      Lesson   @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([lessonId])
  @@index([userId])
  @@index([completedAt])
}
```

## ユーザー設定型定義（TypeScript）
```typescript
// UserのsettingsフィールドのJSON型定義
interface UserSettings {
  // 通知設定
  notifications: {
    push: boolean;
    email: boolean;
    comment: boolean;
    like: boolean;
    follow: boolean;
  };

  // 表示設定
  theme: 'light' | 'dark' | 'auto';
  fontSize: 'small' | 'medium' | 'large';
  language: 'ja' | 'ko' | 'en';

  // タイピング設定
  soundEnabled: boolean;
  hapticEnabled: boolean;
  strictMode: boolean;  // 厳密モード（完全一致のみ）

  // プライバシー設定
  profileVisibility: 'public' | 'followers';
  postDefaultVisibility: 'public' | 'followers' | 'private';
}

// デフォルト設定値
const defaultUserSettings: UserSettings = {
  notifications: {
    push: true,
    email: true,
    comment: true,
    like: true,
    follow: true,
  },
  theme: 'auto',
  fontSize: 'medium',
  language: 'ja',
  soundEnabled: true,
  hapticEnabled: true,
  strictMode: true,
  profileVisibility: 'public',
  postDefaultVisibility: 'public',
};
```

## 環境変数（.env.local）
```bash
# Database
DATABASE_URL="postgresql://user:password@host:5432/dbname"

# Auth0（JWT検証用）
AUTH0_ISSUER_BASE_URL="https://your-tenant-region.auth0.com"
AUTH0_AUDIENCE="https://api.korean-typing.app"           # API識別子
AUTH0_MANAGEMENT_CLIENT_ID="your-management-client-id"   # Management API用
AUTH0_MANAGEMENT_CLIENT_SECRET="your-management-client-secret"

# Vercel Blob
BLOB_READ_WRITE_TOKEN="your-blob-token"

# Redis (Upstash)
UPSTASH_REDIS_REST_URL="your-redis-url"
UPSTASH_REDIS_REST_TOKEN="your-redis-token"

# Pusher
PUSHER_APP_ID="your-pusher-app-id"
PUSHER_KEY="your-pusher-key"
PUSHER_SECRET="your-pusher-secret"
PUSHER_CLUSTER="ap3"

# Sentry (オプション)
SENTRY_DSN="your-sentry-dsn"
```

**注意**: モバイルアプリ向けのため、Web版の認証に必要な `AUTH0_SECRET`, `AUTH0_BASE_URL`, `AUTH0_CLIENT_ID`, `AUTH0_CLIENT_SECRET` は不要です。JWT検証に必要な `AUTH0_ISSUER_BASE_URL` と `AUTH0_AUDIENCE` のみを設定します。
