# 日記機能 - UI/UX設計

> **Note**: このドキュメントは日記機能のUI/UX設計を記載しています。
> 機能仕様は [機能仕様](./14_日記機能の詳細_機能.md) を、
> データモデル設計は [DB設計](./14_日記機能の詳細_DB.md) を、
> API設計は [API設計](./14_日記機能の詳細_API.md) を参照してください。

---
 ## UI/UX設計詳細
 
 ### 画面構成
 
 #### 1. 日記タイムライン画面（diary_screen.dart）
 **既存ファイル**: `application/lib/ui/screens/diary_screen.dart`（モックデータ使用中）
 
 **レイアウト**:
 ```
 ┌─────────────────────────────────┐
 │  📝 日記            [検索アイコン] │
 │                                 │
 │  [おすすめ] [フォロー中] [最新]    │
 │  ────────────────────            │
 │                                 │
 │  ┌───────────────────────────┐  │
 │  │ @username ・ 3時間前       │  │
 │  │                           │  │
 │  │ 韓国語で書いた日記内容...   │  │
 │  │                           │  │
 │  │ [画像があれば表示]         │  │
 │  │                           │  │
 │  │ #ハングル #韓国語          │  │
 │  │                           │  │
 │  │ ♥ 12  💬 3  🔁 1  🔖      │  │
 │  └───────────────────────────┘  │
 │                                 │
 │  [次の投稿カード...]             │
 │                                 │
 │  [+ 新規投稿ボタン（FAB）]       │
 └─────────────────────────────────┘
 ```
 
 **実装が必要な機能**:
 - ✅ タブ切り替え（基本UI実装済み）
 - ❌ 実際のAPIからのデータ取得（現在はモック）
 - ❌ 無限スクロール（infinite_scroll_pagination）
 - ❌ プルトゥリフレッシュ
 - ❌ いいね、コメント、リポストのアクション
 - ❌ 投稿タップでディテール画面へ遷移
 - ❌ FABで投稿作成画面へ遷移
 
 ---
 
 #### 2. 投稿作成画面（**新規作成必要**）
 **画面名**: `post_create_screen.dart`
 
 **レイアウト**:
 ```
 ┌─────────────────────────────────┐
 │  [キャンセル]    新規投稿  [投稿]│
 │                                 │
 │  [@username のアイコン]          │
 │  ┌─────────────────────────┐   │
 │  │ 韓国語で日記を書いて...  │   │
 │  │                         │   │
 │  │ (テキスト入力エリア)     │   │
 │  │                         │   │
 │  └─────────────────────────┘   │
 │  280/280文字                    │
 │                                 │
 │  [選択された画像のプレビュー]     │
 │  [画像1 ×] [画像2 ×]            │
 │                                 │
 │  ───────────────────             │
 │  [📷 画像] [#タグ] [🌐 公開設定] │
 │                                 │
 │  公開設定: 全体公開 ▼             │
 └─────────────────────────────────┘
 ```
 
 **実装機能**:
 - リアルタイム文字数カウント（280文字制限）
 - 画像選択（image_picker使用、最大4枚）
 - 画像プレビューと削除
 - ハッシュタグ自動検出（#で始まる単語）
 - 公開範囲の選択（BottomSheet）
   - 全体公開
   - フォロワーのみ
   - 下書き（自分のみ）
 - バリデーション
   - 空の投稿は禁止
   - 280文字超過の警告
   - 画像アップロードエラー処理
 - 下書き自動保存（オフライン対応）
 
 **Flutter Widgets**:
 - `TextField` (maxLines: null, maxLength: 280)
 - `FButton` (送信ボタン)
 - `GridView` (画像プレビュー)
 - `BottomSheet` (公開範囲選択)
 
 ---
 
 #### 3. 投稿ディテール画面（**新規作成必要**）
 **画面名**: `post_detail_screen.dart`
 
 **レイアウト**:
 ```
 ┌─────────────────────────────────┐
 │  [← 戻る]       投稿             │
 │                                 │
 │  ┌───────────────────────────┐  │
 │  │ 元の投稿カード             │  │
 │  │ (PostCard widget再利用)   │  │
 │  │                           │  │
 │  │ ♥ 12  💬 3  🔁 1  🔖      │  │
 │  └───────────────────────────┘  │
 │                                 │
 │  コメント (12)                  │
 │  ────────────────                │
 │                                 │
 │  ┌───────────────────────────┐  │
 │  │ @user1 ・ 2時間前         │  │
 │  │ コメント内容...           │  │
 │  │         ♥ 3               │  │
 │  └───────────────────────────┘  │
 │                                 │
 │  ┌───────────────────────────┐  │
 │  │ @user2 ・ 5時間前         │  │
 │  │ コメント内容...           │  │
 │  │         ♥ 1               │  │
 │  └───────────────────────────┘  │
 │                                 │
 │  ───────────────────             │
 │  [コメントを追加...]   [送信]    │
 └─────────────────────────────────┘
 ```
 
 **実装機能**:
 - 元の投稿の表示（PostCardウィジェット再利用）
 - コメント一覧の無限スクロール
 - コメントへのいいね
 - コメント投稿
   - 最大280文字の制限
   - リアルタイム文字数カウント表示（オプション）
   - 空のコメントは送信不可
   - バリデーションエラーの表示
 - コメント削除機能
   - **自分のコメントのみ削除可能**
   - 他人のコメントには削除ボタンを表示しない
   - 削除確認ダイアログを表示
 
 ---
 
 #### 4. ユーザープロフィール画面（既存）
 **既存ファイル**: `application/lib/ui/screens/profile_screen.dart`
 
 **追加が必要な機能**:
 - 「投稿」タブの実装（現在の実装を確認する必要あり）
 - フォロー/アンフォローボタン
 - フォロワー/フォロー中カウントのタップでリスト表示
 - 他人のプロフィール閲覧時の「...」メニュー
   - ブロック
   - 報告
 
 ---
 
 #### 5. 通知画面（**新規作成必要**）
 **画面名**: `notifications_screen.dart`
 
 **レイアウト**:
 ```
 ┌─────────────────────────────────┐
 │  [← 戻る]       通知             │
 │                                 │
 │  [全て] [未読のみ]               │
 │  ────────────────                │
 │                                 │
 │  ┌───────────────────────────┐  │
 │  │ ● @user1 があなたの投稿に   │  │
 │  │   いいねしました            │  │
 │  │   "오늘은 한국어로..."      │  │
 │  │   3時間前                  │  │
 │  └───────────────────────────┘  │
 │                                 │
 │  ┌───────────────────────────┐  │
 │  │   @user2 があなたをフォロー │  │
 │  │   しました   [フォローバック]│  │
 │  │   1日前                    │  │
 │  └───────────────────────────┘  │
 │                                 │
 │  ┌───────────────────────────┐  │
 │  │ ● @user3 があなたの投稿に   │  │
 │  │   コメントしました          │  │
 │  │   "멋진 글이네요!"         │  │
 │  │   2日前                    │  │
 │  └───────────────────────────┘  │
 └─────────────────────────────────┘
 ```
 
 **実装機能**:
 - 通知タイプ別のアイコン表示
   - ❤️ いいね
   - 💬 コメント
   - 🔁 リポスト
   - 👥 フォロー
 - 未読/既読の視覚的区別（●マークと背景色）
 - タブ切り替え（全て/未読のみ）
 - タップで関連する投稿/ユーザーへ移動
 - プルトゥリフレッシュ
 - 「全て既読にする」ボタン
 
 ---
 
 #### 6. 検索画面（**新規作成必要**）
 **画面名**: `search_screen.dart`
 
 **レイアウト**:
 ```
 ┌─────────────────────────────────┐
 │  [← 戻る]  [🔍 検索ボックス]     │
 │                                 │
 │  [投稿] [ユーザー] [ハッシュタグ] │
 │  ────────────────                │
 │                                 │
 │  トレンド                        │
 │  #한국어공부  1.2k投稿            │
 │  #타이핑연습  856投稿             │
 │                                 │
 │  ───── 検索結果 ─────            │
 │  [検索結果のリスト]              │
 │                                 │
 └─────────────────────────────────┘
 ```
 
 **実装機能**:
 - リアルタイム検索（デバウンス処理）
 - タブ切り替え（投稿/ユーザー/ハッシュタグ）
 - 検索履歴の保存（SharedPreferences）
 - トレンドハッシュタグの表示
 - 検索結果の無限スクロール
 
 ---
 
 #### 7. ブックマーク画面（**新規作成必要**）
 **画面名**: `bookmarks_screen.dart`
 
 **レイアウト**:
 ```
 ┌─────────────────────────────────┐
 │  [← 戻る]     ブックマーク       │
 │                                 │
 │  [保存した投稿のタイムライン]    │
 │  (PostCard widget再利用)        │
 │                                 │
 └─────────────────────────────────┘
 ```
 
 **実装機能**:
 - ブックマークした投稿一覧
 - 無限スクロール
 - 投稿カードのタップでディテール画面へ
 - ブックマーク解除機能
 
 ---
 
 ### 再利用可能なウィジェット
 
 #### 1. PostCard (`widgets/post_card.dart`)
 **投稿カードの共通コンポーネント**
 
 **プロップス**:
 ```dart
 class PostCard extends StatelessWidget {
   final Post post;
   final VoidCallback? onLike;
   final VoidCallback? onComment;
   final VoidCallback? onRepost;
   final VoidCallback? onBookmark;
   final VoidCallback? onTap;
   final bool showActions; // アクションボタンの表示/非表示
 }
 ```
 
 **内部構造**:
 - **通常のリポストの場合**: 「@username がリポストしました」ヘッダー
 - ユーザーアバター + 名前 + タイムスタンプ
 - 投稿本文
 - **Quoteリポストの場合**: 引用カード（引用元の投稿を縮小表示）
 - 画像グリッド（1-4枚対応）
 - ハッシュタグチップ
 - アクションボタン行（いいね、コメント、リポスト、ブックマーク）
 
 **表示ロジック**:
 ```dart
 // 通常のリポストの判定
 if (post.repostInfo?.isRepost == true) {
   // 「@username がリポストしました」を表示
 }
 
 // Quoteリポストの判定
 if (post.quotedPostId != null && post.quotedPost != null) {
   // 引用カードを表示
 }
 ```
 
 ---
 
 #### 2. CommentCard (`widgets/comment_card.dart`)
 **コメントカード**
 
 **プロップス**:
 ```dart
 class CommentCard extends StatelessWidget {
   final Comment comment;
   final VoidCallback? onLike;
   final VoidCallback? onDelete;
   final bool canDelete; // 自分のコメントかどうか（削除権限の判定）
 }
 ```
 
 **削除権限の判定**:
 ```dart
 // 現在のユーザーIDとコメント投稿者のIDを比較
 final canDelete = currentUser?.id == comment.userId;
 
 CommentCard(
   comment: comment,
   canDelete: canDelete,
   onDelete: canDelete ? () => deleteComment(comment.id) : null,
 );
 ```
 
 **UI実装**:
 - `canDelete == true` の場合のみ、削除ボタンまたはメニューアイテムを表示
 - 削除ボタンをタップすると、確認ダイアログを表示
   - 「このコメントを削除しますか？」
   - [キャンセル] [削除] ボタン
 - 削除成功後、コメント一覧から該当コメントを削除し、UI を更新
 
 ---
 
 #### 3. UserAvatar (`widgets/user_avatar.dart`)
 **ユーザーアバター**
 
 **プロップス**:
 ```dart
 class UserAvatar extends StatelessWidget {
   final String? imageUrl;
   final String displayName;
   final double size;
   final VoidCallback? onTap;
 }
 ```
 
 **実装**:
 - imageUrlがnullの場合はイニシャル表示
 - CircleAvatarを使用
 
 ---
 
 #### 4. ActionButton (`widgets/action_button.dart`)
 **いいね、コメント、リポストボタン**
 
 **プロップス**:
 ```dart
 class ActionButton extends StatelessWidget {
   final IconData icon;
   final String label;
   final VoidCallback? onPressed;
   final bool isActive; // アクティブ状態（いいね済み等）
   final Color? activeColor;
 }
 ```
 
 ---
 
 #### 5. ImageGrid (`widgets/image_grid.dart`)
 **複数画像の表示（1-4枚対応）**
 
 **プロップス**:
 ```dart
 class ImageGrid extends StatelessWidget {
   final List<String> imageUrls;
   final double aspectRatio;
 }
 ```
 
 **レイアウトロジック**:
 - 1枚: 全幅表示
 - 2枚: 横並び
 - 3枚: 1枚大 + 2枚縦並び
 - 4枚: 2x2グリッド
 
 ---
 
 #### 6. HashtagChip (`widgets/hashtag_chip.dart`)
 **ハッシュタグチップ**
 
 **プロップス**:
 ```dart
 class HashtagChip extends StatelessWidget {
   final String tag;
   final VoidCallback? onTap;
 }
 ```
 
 ---
 
 ### デザインシステム
 
 #### カラー
 - **Primary**: `AppColors.primaryBright` - メインアクション
 - **Secondary**: `AppColors.secondary` - セカンダリアクション
 - **Accent**: `AppColors.accentEnd` - 強調表示
 - **Error**: `Colors.red` - エラー表示
 - **Surface**: `Theme.of(context).colorScheme.surface` - カード背景
 - **OnSurface**: `Theme.of(context).colorScheme.onSurface` - テキスト色
 
 #### タイポグラフィ
 - **headlineSmall**: 画面タイトル（24px）
 - **titleMedium**: 投稿タイトル、ユーザー名（16px Bold）
 - **bodyLarge**: 投稿本文（16px）
 - **bodyMedium**: メタ情報（14px）
 - **bodySmall**: キャプション、タイムスタンプ（12px）
 
 #### スペーシング
 ```dart
 class Spacing {
   static const xs = 4.0;
   static const s = 8.0;
   static const m = 12.0;
   static const l = 16.0;
   static const xl = 20.0;
   static const xxl = 24.0;
 }
 ```
 
 #### アニメーション
 - **いいねボタン**:
   - スケールアニメーション（0.8 → 1.2 → 1.0）
   - カラー変化（grey → red）
   - Duration: 300ms
 - **画面遷移**: マテリアルデザインの標準遷移
 - **プルトゥリフレッシュ**: スムーズなローディング表示
 
 ---
 
 ## 実装上の指摘事項・懸念点
 
 ### 🚨 Critical（実装前に必ず対応が必要）
 
 #### 1. データモデルの不足
 以下のモデルが仕様に記載されているが、Prismaスキーマに存在しません：
 - ❌ **Repost**: リポスト機能に必須
 - ❌ **Bookmark**: ブックマーク機能に必須
 - ❌ **Notification**: 通知機能に必須
 - ❌ **CommentLike**: コメントへのいいね機能に必須（仕様書35行目で要求）
 - ❌ **Report**: 報告機能に必須
 - ❌ **Block**: ブロック機能に必須
 
 **対応方法**: 上記「追加が必要なモデル」セクションのPrismaスキーマを追加し、マイグレーシ
ョンを実行してください。
 
 ---
 
 #### 2. Commentモデルの拡張
 現在のCommentモデルには`likesCount`フィールドがありませんが、仕様書35行目で「コメントにも
いいね可能」とあります。
 
 **必要な変更**:
 ```prisma
 model Comment {
   id        String   @id @default(cuid())
   content   String
   postId    String
   userId    String
   likesCount Int     @default(0)  // ← 追加
   createdAt DateTime @default(now())
   updatedAt DateTime @updatedAt    // ← 追加推奨
 
   post      Post         @relation(fields: [postId], references: [id])
   user      User         @relation(fields: [userId], references: [id])
   likes     CommentLike[] // ← 追加
 }
 ```
 
 ---
 
 #### 3. Postモデルへの追加フィールド
 リポスト機能を実装する場合、Postモデルに以下を追加することを検討してください：
 ```prisma
 model Post {
   // 既存フィールド...
   repostsCount Int     @default(0)  // リポスト数
   bookmarksCount Int   @default(0)  // ブックマーク数（任意）
 
   // リレーション追加
   reposts    Repost[]
   bookmarks  Bookmark[]
 }
 ```
 
 ---
 
 #### 4. 画像アップロード実装仕様
 画像添付機能の実装詳細：
 
 **ストレージサービス**:
 - ✅ **Vercel Blob Storage**を使用
 - Vercelとの統合が容易
 - 自動でCDN配信
 
 **画像の圧縮・バリデーション**:
 - サーバー側で圧縮を実行
 - 最大ファイルサイズ制限: **5MB/枚**
 - リサイズ後のサイズ: **最大幅1920px**
 - 対応フォーマット: **JPEG, PNG のみ**
 
 **アップロードフロー**:
 ```
 クライアント → Next.js API → Vercel Blob → CDN URL返却
 ```
 
 **実装詳細**:
 - バックエンド: `POST /api/upload/image` エンドポイント
 - ライブラリ:
   - `@vercel/blob` - Vercel Blob Storage SDK
   - `sharp` - 画像圧縮・リサイズ
 - 処理フロー:
   1. クライアントから画像をmultipart/form-dataで受信
   2. sharpで検証・圧縮・リサイズ
   3. Vercel Blobにアップロード
   4. CDN URLをクライアントに返却
 
 **セキュリティ**:
 - ファイルタイプの検証（MIMEタイプ + Magic Number）
 - ファイルサイズ制限の強制
 - レート制限（1分間に最大10枚）
 
 ---
 
 #### 5. 「おすすめ」フィードのアルゴリズム実装仕様
 スコアベースのランキングアルゴリズムを実装します（簡易版）。
 
 **フィードの種類**:
 - `recommended`: スコアベースのおすすめ（以下のアルゴリズム）
 - `following`: フォロー中のユーザーの投稿（時系列順）
 - `latest`: 全ユーザーの投稿（時系列順）
 
 **recommendedフィードの実装**:
 
 ```typescript
 // スコアベースのランキング（簡易版）
 const calculateScore = (post: Post): number => {
   const now = Date.now()
   const ageInHours = (now - post.createdAt.getTime()) / (1000 * 60 * 60)
 
   // エンゲージメントスコア
   const engagementScore = (
     post.likesCount * 1.0 +
     post.commentsCount * 2.0 +
     post.repostsCount * 1.5
   )
 
   // 時間減衰（古い投稿はスコアが下がる）
   const timeDecay = Math.pow(ageInHours + 2, 1.5)
 
   return engagementScore / timeDecay
 }
 ```
 
 **実装方法**:
 1. **データベースで取得**: 過去7日間の投稿を取得
 2. **スコア計算**: アプリケーション層でスコアを計算
 3. **ソート**: スコア降順でソート
 4. **ページネーション**: cursor-basedページネーションで返却
 
 **注意点**:
 - 初期実装はシンプルに保つ
 ---
 
 #### 6. 全文検索の実装仕様
 韓国語対応の全文検索機能を実装します。
 
 **採用する方法**: ✅ **PostgreSQL pg_trgm拡張**
 
 **Vercel Neon（PostgreSQL）での対応**:
 - ✅ Neonはpg_trgm拡張をサポート
 - トライグラム索引で部分一致検索が可能
 - 韓国語のような表意文字にも対応
 
 **実装手順**:
 
 1. **拡張機能の有効化**:
 ```sql
 CREATE EXTENSION IF NOT EXISTS pg_trgm;
 ```
 
 2. **インデックスの作成**:
 ```sql
 -- 投稿の全文検索用インデックス
 CREATE INDEX idx_posts_content_trgm ON posts USING gin (content gin_trgm_ops);
 
 -- ユーザー名検索用インデックス
 CREATE INDEX idx_users_display_name_trgm ON users USING gin (display_name gin_trgm_ops);
 CREATE INDEX idx_users_username_trgm ON users USING gin (username gin_trgm_ops);
 ```
 
 3. **検索クエリ実装**:
 ```typescript
 // 投稿検索
 const searchPosts = await prisma.$queryRaw`
   SELECT * FROM posts
   WHERE content % ${searchQuery}
   ORDER BY similarity(content, ${searchQuery}) DESC
   LIMIT 20
 `
 
 // ハッシュタグ検索（部分一致）
 const hashtagPosts = await prisma.post.findMany({
   where: {
     tags: {
       hasSome: tags.filter(tag =>
         tag.toLowerCase().includes(searchQuery.toLowerCase())
       )
     }
   }
 })
 ```
 
 **パフォーマンス考慮**:
 - 類似度スコア: `similarity()`関数を使用（0.0〜1.0）
 - しきい値設定: `SET pg_trgm.similarity_threshold = 0.3;`（推奨）
 - 検索結果は類似度順にソート
 
 **将来の拡張**:
 - ユーザー数が増えた場合、Elasticsearchへの移行を検討
 
 ---
 
 ### ⚠️ Warning（実装時に注意が必要）
 
 #### 7. リポスト表示の仕様（確定）
 
 **データモデル**:
 - ✅ **通常のリポスト**（コメントなし）: `Repost` テーブルで管理
 - ✅ **Quoteリポスト**（コメント付き）: `Post` テーブルで管理（`quotedPostId` 
を持つ独立した投稿）
 - ✅ タイムラインには通常の投稿、通常のリポスト、Quoteリポストを混在表示
 
 **タイムラインレスポンスの構造**:
 
 ```json
 {
   "data": [
     // 通常の投稿
     {
       "id": "post1",
       "content": "通常の投稿です",
       "quotedPostId": null,
       "repostInfo": { "isRepost": false }
     },
     // 通常のリポスト（コメントなし）
     {
       "id": "original_post2",
       "content": "元の投稿",
       "quotedPostId": null,
       "repostInfo": {
         "isRepost": true,
         "repostedBy": { "username": "user1" },
         "repostedAt": "ISO8601"
       }
     },
     // Quoteリポスト（独立した投稿）
     {
       "id": "quote_post3",
       "content": "私のコメント",
       "quotedPostId": "original_post4",
       "quotedPost": {
         "id": "original_post4",
         "content": "引用元の投稿",
         "user": { "username": "user2" }
       },
       "repostInfo": { "isRepost": false }
     }
   ]
 }
 ```
 
 **投稿の種類の判定**:
 1. **通常の投稿**: `quotedPostId == null && repostInfo.isRepost == false`
 2. **通常のリポスト**: `repostInfo.isRepost == true`
 3. **Quoteリポスト**: `quotedPostId != null`
 
 **UI表示**:
 - **通常の投稿**: そのまま表示
 - **通常のリポスト**: 投稿カードの上部に「@username がリポストしました」と表示
 - **Quoteリポスト**: 上部に投稿者のコメント、下部に引用カードとして元投稿を表示
 
 **重複排除ロジック（詳細）**:
 
 **基本方針**: 
同じ投稿が複数のフォロワーにリポストされた場合、個別に表示する（集約しない）
 
 **タイムラインでの表示**:
 1. **おすすめフィード（`recommended`）**:
    - 同じ `originalPostId` のリポストが複数ある場合、スコアが高いものを優先
    - 同一ユーザーが同じ投稿を複数回リポストすることは Prisma の `@@unique([userId, 
originalPostId])` で防止
 2. **フォロー中フィード（`following`）**:
    - フォローしているユーザーのリポストを全て表示
    - 例: @userA と @userB が同じ投稿をリポストした場合、両方とも表示
      ```
      @userA がリポストしました
      [元の投稿]
 
      @userB がリポストしました
      [元の投稿]
      ```
 3. **最新フィード（`latest`）**:
    - 全てのリポストを時系列順に表示（重複排除なし）
 
 **集約表示の不採用理由**:
 - 初期実装ではシンプルさを優先
 - 「@user1と他2人がリポストしました」のような集約表示は実装しない
 - 将来の拡張機能として検討可能
 
 **API実装での考慮点**:
 ```typescript
 // フォロー中フィードの例
 const posts = await prisma.post.findMany({
   where: {
     OR: [
       // 通常の投稿
       { userId: { in: followingUserIds } },
       // リポスト
       { reposts: { some: { userId: { in: followingUserIds } } } }
     ]
   },
   include: {
     reposts: {
       where: { userId: { in: followingUserIds } },
       orderBy: { createdAt: 'desc' },
       take: 1 // フォロワーの中で最新のリポストのみ
     }
   }
 });
 ```
 
 **実装における注意点**:
 - タイムラインクエリでは、通常の投稿と Repost を JOIN して取得
 - `repostInfo.isRepost = false` の場合、`repostedBy`, `repostedAt`, `quoteComment` は 
null
 - リポストの `createdAt` 
は元投稿の作成日時ではなく、リポスト日時（`repostedAt`）を基準にソート
 
 ---
 
 #### 8. 通知の実装仕様
 プッシュ通知機能を実装します。
 
 **採用する方法**: ✅ **Push Notification (Firebase Cloud Messaging)**
 
 **実装詳細**:
 
 1. **Flutter側（クライアント）**:
 ```yaml
 # pubspec.yaml
 dependencies:
   firebase_core: ^latest
   firebase_messaging: ^latest
 ```
 
 ```dart
 // FCMトークンの取得・保存
 final fcmToken = await FirebaseMessaging.instance.getToken();
 // バックエンドにトークンを送信（PUT /api/users/me/push-token）
 await apiClient.put('/users/me/push-token', data: {'fcmToken': fcmToken});
 
 // ログアウト時のトークン削除（DELETE /api/users/me/push-token）
 await apiClient.delete('/users/me/push-token');
 
 // フォアグラウンド通知の受信
 FirebaseMessaging.onMessage.listen((RemoteMessage message) {
   // 通知を表示
   showNotification(message);
 });
 ```
 
 2. **Backend側（Next.js）**:
 ```typescript
 // Firebase Admin SDKを使用
 import admin from 'firebase-admin';
 
 // 通知送信関数
 async function sendNotification(
   userId: string,
   notification: {
     title: string;
     body: string;
     data?: Record<string, string>;
   }
 ) {
   // ユーザーのFCMトークンを取得
   const user = await prisma.user.findUnique({
     where: { id: userId },
     select: { fcmToken: true }
   });
 
   if (!user?.fcmToken) return;
 
   // FCMで通知を送信
   await admin.messaging().send({
     token: user.fcmToken,
     notification: {
       title: notification.title,
       body: notification.body,
     },
     data: notification.data,
   });
 }
 ```
 
 3. **データモデル更新**:
 ```prisma
 model User {
   // 既存フィールド...
   fcmToken String? // FCMデバイストークン
 }
 ```
 
 4. **通知トリガー**:
 - いいね: `POST /api/posts/{postId}/like` 実行時
 - コメント: `POST /api/posts/{postId}/comments` 実行時
 - リポスト: `POST /api/posts/{postId}/repost` 実行時
 - フォロー: `POST /api/follows` 実行時
 
 **通知設定**:
 - ユーザーごとに通知ON/OFF切り替え可能
 - `User.settings` JSONフィールドに保存:
 ```json
 {
   "notifications": {
     "likes": true,
     "comments": true,
     "reposts": true,
     "follows": true
   }
 }
 ```
 
 **将来の拡張**:
 - バッジカウントの管理
 - 通知のグルーピング（例: "○○さんと他3人があなたの投稿にいいねしました"）
 - リッチ通知（画像付き）
 
 ---
 
 #### 9. ブロック機能の詳細仕様
 
 ##### ブロック実行時の処理
 1. **`POST /api/blocks` 実行時**:
    - Blockレコードを作成
    - 相互のフォロー関係を自動的に解除
    - `User.followersCount`, `followingCount` を更新
    - ブロックされたユーザーには通知しない
 
 ##### ブロックの影響範囲
 
 **タイムライン・フィード（`GET /api/posts`）**:
 - ✅ ブロックしたユーザーの投稿は表示しない
 - ✅ ブロックされたユーザー側でも、ブロックしたユーザーの投稿は表示しない
 - ✅ リポストも表示しない
 
 **検索（`GET /api/search`）**:
 - ✅ ブロック関係にあるユーザーの投稿は検索結果に含めない
 - ✅ ユーザー検索でも相互に表示しない
 
 **プロフィール閲覧（`GET /api/users`）**:
 - ✅ ブロックしたユーザーのプロフィールは閲覧可能（ブロック中であることを表示）
 - ✅ ブロックされたユーザーが閲覧しようとした場合は **403 Forbidden**
   - エラーメッセージ: `"このユーザーはあなたをブロックしています"`
 
 **投稿詳細・コメント（`GET /api/posts/{postId}`）**:
 - ✅ 過去のコメントは削除せず、データは残す
 - ✅ UI表示時は「このコメントは表示できません」と表示
 - ✅ ブロック関係にあるユーザーのコメントはAPIレスポンスから除外
 
 **通知（`GET /api/notifications`）**:
 - ✅ ブロック関係にあるユーザーからの通知は表示しない
 - ✅ 既存の通知も非表示にする（データは残す）
 
 **いいね・リポスト**:
 - ✅ ブロック関係にあるユーザーの投稿には「いいね」「リポスト」ができない
 - ✅ 実行時は **403 Forbidden**
   - エラーメッセージ: `"この操作は実行できません"`
 
 **フォロー**:
 - ✅ ブロック関係にあるユーザーはフォローできない
 - ✅ フォロー実行時は **403 Forbidden**
   - エラーメッセージ: `"このユーザーをフォローできません"`
 
 ##### ブロック解除時の処理
 1. **`DELETE /api/blocks/{blockId}` 実行時**:
    - Blockレコードを削除
    - フォロー関係は自動的には復元しない（手動でフォローが必要）
 
 ##### 実装の考慮点
 
 **パフォーマンス最適化**:
 - ブロック関係のチェックは、ユーザーIDをキーにしたキャッシュ（Vercel KV）を活用
 - N+1問題を避けるため、バルクでブロック関係を取得
   ```typescript
   // 良い例
   const blockedUserIds = await getBlockedUserIds(viewerId);
   const posts = posts.filter(p => !blockedUserIds.includes(p.userId));
 
   // 悪い例（N+1問題）
   for (const post of posts) {
     if (await isBlocked(viewerId, post.userId)) { ... }
   }
   ```
 
 **API実装での共通チェック関数**:
 ```typescript
 async function checkBlockRelationship(userId1: string, userId2: string): Promise<boolean>
 {
   // user1がuser2をブロックしているか、またはその逆
   const block = await prisma.block.findFirst({
     where: {
       OR: [
         { blockerId: userId1, blockedId: userId2 },
         { blockerId: userId2, blockedId: userId1 }
       ]
     }
   });
   return !!block;
 }
 ```
 
 **HTTPステータスコード**:
 - ブロックされているユーザーがアクセスした場合: **403 Forbidden**
 - クライアント側でのエラーハンドリング例:
   ```dart
   if (response.statusCode == 403) {
     showDialog(
       context: context,
       builder: (_) => AlertDialog(
         title: Text('アクセスできません'),
         content: Text(error.message),
       ),
     );
   }
   ```
 
 ---
 
 #### 10. オフライン対応の詳細仕様（Level 1）
 
 **採用する実装レベル**: Level 1（下書き保存のみ）
 
 ##### 下書き保存の実装詳細
 
 **保存先**:
 - `SharedPreferences` を使用してローカルに保存
 - キー: `draft_posts`
 - 値: JSON形式の下書きリスト
 
 **保存するデータ構造**:
 ```dart
 class DraftPost {
   final String id; // ローカルID（UUID生成）
   final String content;
   final List<String> imageUrls; // ローカルパス
   final String visibility;
   final List<String> tags;
   final DateTime createdAt;
   final DateTime updatedAt;
 }
 ```
 
 **保存タイミング**:
 - 投稿作成画面で「下書きとして保存」ボタンを押した時
 - オフライン時に投稿ボタンを押した時（自動的に下書きとして保存）
 - アプリがバックグラウンドに移行する時（自動保存）
 
 **同期トリガー**:
 1. **オンライン復帰時の自動同期**:
    - `connectivity_plus` パッケージでネットワーク状態を監視
    - オンラインに復帰したら、下書き一覧を自動アップロード
    - 同期中はローディング表示
 
 2. **手動同期**:
    - 下書き一覧画面に「同期」ボタンを用意
    - ユーザーが明示的に同期を実行可能
 
 **同期処理のフロー**:
 ```dart
 Future<void> syncDrafts() async {
   final drafts = await getDraftPosts();
 
   for (final draft in drafts) {
     try {
       // 画像があれば先にアップロード
       final imageUrls = await uploadImages(draft.localImagePaths);
 
       // 投稿を作成（サーバー側でvisibility=privateとして保存）
       await apiClient.createPost(
         content: draft.content,
         imageUrls: imageUrls,
         visibility: 'private', // サーバー側の下書きとして保存
         tags: draft.tags,
       );
 
       // 同期成功したらローカルの下書きを削除
       await deleteDraftPost(draft.id);
     } catch (e) {
       // 失敗した下書きはそのまま残す
       print('Failed to sync draft: $e');
     }
   }
 }
 ```
 
 **UI表示**:
 - 下書き一覧画面（設定画面内またはプロフィール内）
 - 各下書きに「編集」「削除」「投稿」ボタンを表示
 - 同期中は「同期中...」と表示
 - 同期失敗時はエラーメッセージを表示
 
 **エラーハンドリング**:
 - ネットワークエラー時: 再試行を促すメッセージ
 - サーバーエラー時: エラー詳細を表示し、下書きは削除しない
 - 画像アップロード失敗時: 画像なしで投稿するか確認
 
 **将来の拡張（Level 2）**:
 - `flutter_cache_manager` で過去の投稿をキャッシュ
 - オフライン時でもタイムライン閲覧可能（キャッシュから）
 - 画像の自動キャッシュ
 
 ---
 
 ### 💡 追加改善提案
 
 #### コメントのページネーション戦略
 コメント数が多い投稿の場合、パフォーマンスが悪化する可能性があります。
 
 **推奨実装**:
 ```
 GET /api/posts/{postId}/comments?sort=popular  // 人気順
 GET /api/posts/{postId}/comments?sort=newest   // 新着順
 ```
 
 デフォルトは「人気順」（likesCount降順）にして、最初は10件のみ表示。
 
 ---
 
 ## まとめ
 
 ### 確定した実装方針
 
 1. ✅ **画像ストレージ**: Vercel Blob Storage
 2. ✅ **通知方式**: Firebase Cloud Messaging (Push Notification)
 3. ✅ **全文検索**: PostgreSQL pg_trgm拡張（Vercel Neon対応）
 4. ✅ **おすすめアルゴリズム**: スコアベースランキング（簡易版）
 5. ✅ **APIレート制限**: Vercel KV + @upstash/ratelimit
 6. ✅ **画像遅延読み込み**: cached_network_image
 7. ✅ **ハッシュタグ正規化**: 英語は小文字、韓国語・日本語はそのまま
 8. ✅ **投稿の編集機能**: 24時間以内編集可能
 
 ### 実装前に対応が必要な項目
 
 1. **データモデルの追加・拡張**:
    - Userモデルに`fcmToken`フィールド追加
    - Postモデルに`isEdited`, `editedAt`, `repostsCount`, `quotesCount`, 
`quotedPostId`フィールド追加
    - Commentモデルに`likesCount`, `updatedAt`フィールド追加
    - 新規モデル: Repost, Bookmark, Notification, CommentLike, Report, Block
 2. **データベースマイグレーション**:
    - Prismaスキーマを更新
    - `npx prisma migrate dev`でマイグレーション実行
    - pg_trgm拡張の有効化
 3. **Firebase設定**:
    - Firebase Projectの作成
    - FCM APIキーの取得
    - Flutter・Backendへの設定追加
 4. **Vercel Blob設定**:
    - Vercel Blobストレージの有効化
    - 環境変数の設定
 
 ### 推奨される実装順序
 
 #### Phase 1: 基本機能（MVP）
 1. **環境設定**:
    - Firebase Projectの作成・設定
    - Vercel Blobの有効化
    - Vercel KVの有効化
 2. **データモデル追加・マイグレーション**:
    - Prismaスキーマの更新（User, Post, Commentの拡張）
    - pg_trgm拡張の有効化
    - マイグレーション実行
 3. **画像アップロード機能**:
    - `POST /api/upload/image` エンドポイント実装
    - Vercel Blob統合
    - sharp による画像圧縮
 4. **投稿作成・編集機能**:
    - `POST /api/posts` 強化
    - `PATCH /api/posts/{postId}` 実装
    - ハッシュタグ正規化の実装
    - 投稿作成画面（Flutter）の実装
 5. **タイムライン機能**:
    - おすすめアルゴリズムの実装
    - タイムラインの実データ取得（Flutter）
    - 無限スクロール実装
    - 画像遅延読み込み（cached_network_image）
 6. **いいね機能**:
    - `POST /api/posts/{postId}/like` 実装
    - `DELETE /api/posts/{postId}/like` 実装
 7. **コメント機能**:
    - `GET /api/posts/{postId}/comments` 実装
    - `POST /api/posts/{postId}/comments` 実装
    - `DELETE /api/comments/{commentId}` 実装
    - 投稿ディテール画面（Flutter）の実装
 8. **APIレート制限**:
    - Vercel KV + @upstash/ratelimit統合
    - 各エンドポイントにレート制限適用
 
 #### Phase 2: インタラクション機能
 1. **リポスト機能**:
    - Repostモデルの追加
    - Postモデルに `quotedPostId` フィールドを追加
    - `POST /api/posts/{postId}/repost` 実装（通常のリポスト）
    - `DELETE /api/posts/{postId}/repost` 実装
    - `POST /api/posts` でQuoteリポスト対応（`quotedPostId` を指定）
 2. **ブックマーク機能**:
    - Bookmarkモデルの追加
    - `POST /api/posts/{postId}/bookmark` 実装
    - `GET /api/bookmarks` 実装
    - ブックマーク画面（Flutter）の実装
 3. **全文検索機能**:
    - pg_trgmインデックスの作成
    - `GET /api/search` 実装
    - 検索画面（Flutter）の実装
 4. **コメントへのいいね**:
    - CommentLikeモデルの追加
    - `POST /api/comments/{commentId}/like` 実装
 
 #### Phase 3: 通知機能
 1. **通知データモデル**:
    - Notificationモデルの追加
 2. **Push Notification実装**:
    - Firebase Admin SDK統合（Backend）
    - FCMトークン保存API実装
    - 通知送信関数の実装
    - firebase_messaging統合（Flutter）
 3. **通知一覧画面**:
    - `GET /api/notifications` 実装
    - `PATCH /api/notifications/{id}/read` 実装
    - 通知画面（Flutter）の実装
 
 #### Phase 4: 安全機能
 1. **報告機能**:
    - Reportモデルの追加
    - `POST /api/reports` 実装
 2. **ブロック機能**:
    - Blockモデルの追加
    - `POST /api/blocks` 実装
    - `GET /api/blocks` 実装
    - タイムライン・プロフィールでのブロックユーザーフィルタリング
 
 #### Phase 5: 拡張機能（将来）
 1. オフライン対応（下書き保存）
 2. 通知のグルーピング
 3. リッチ通知（画像付き）
 4. おすすめアルゴリズムの改善（ユーザーの興味関心ベース）
 
 ---
 
 ## 技術的な注意事項
 
 ### パフォーマンス最適化
 - **N+1問題の回避**: Prismaの`include`を適切に使用
 - **インデックスの活用**: `userId`, `createdAt`, `likesCount`等に適切なインデックス
 - **画像最適化**: Vercel BlobのCDN活用
 - **無限スクロール**: cursor-basedページネーションの使用
 
 ### セキュリティ
 - **認証**: すべての変更系APIでAuth0 JWT検証
 - **認可**: ユーザーは自分の投稿のみ編集・削除可能
 - **レート制限**: 適切なレート制限でスパム防止
 - **入力検証**: すべての入力データを検証（文字数制限、画像サイズ等）
 
 ### テスト
 - **単体テスト**: 各API RouteにJestテストを追加
 - **統合テスト**: 主要なフローをテスト
 - **E2Eテスト**: Flutter Integration Testで主要画面をテスト