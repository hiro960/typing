# タイピング機能の詳細仕様

## 目次
1. [機能概要とユーザーフロー](#1-機能概要とユーザーフロー)
2. [レッスンデータ構造](#2-レッスンデータ構造)
3. [ホーム画面（レーン選択）](#3-ホーム画面レーン選択)
4. [レッスン選択](#4-レッスン選択)
5. [タイピング画面の詳細](#5-タイピング画面の詳細)
6. [完了画面とデータ送信](#6-完了画面とデータ送信)
7. [状態管理（Riverpod設計）](#7-状態管理riverpod設計)
8. [データフロー](#8-データフロー)
9. [エラーハンドリング](#9-エラーハンドリング)
10. [パフォーマンス最適化](#10-パフォーマンス最適化)
11. [今後の拡張可能性](#11-今後の拡張可能性)

---

## 1. 機能概要とユーザーフロー

### 1.1 全体フロー
```
ホーム画面（レーン選択）
    ↓ レーンを選択（初級/中級/上級）
    ↓
レッスン一覧表示
    ↓ レッスンを選択
    ↓
レッスン詳細確認
    ↓ 「開始」ボタンをタップ
    ↓
タイピング画面
    ↓ 入力・検証をリアルタイムで実行
    ↓ すべての問題を完了
    ↓
完了画面
    ↓ 結果表示・バックエンドへ送信
    ↓
次のアクション選択
    ├─ 次のレッスンへ
    ├─ 同じレッスンを再挑戦
    └─ ホームに戻る
```

### 1.2 各画面の役割

| 画面 | 役割 | 主要機能 |
|------|------|----------|
| ホーム画面 | レーン選択とユーザー統計表示 | 3つのレーン（初級/中級/上級）、ユーザーの学習統計、進捗状況 |
| レッスン選択 | 個別レッスンの選択と詳細確認 | レッスンタイトル、説明、プログレス、最高記録 |
| タイピング画面 | 実際のタイピング練習 | 韓国語入力、リアルタイム検証、ヒント表示、タイマー |
| 完了画面 | 結果表示と次のアクション | スコア、統計、弱点分析、次へ進む or 再挑戦 |

---

## 2. レッスンデータ構造

### 2.1 データ保存方法
**アプリ内にJSONファイルとして同梱**
- パス: `application/assets/lessons/`
- ファイル名: `{level}_{order}.json` (例: `beginner_001.json`)
- オフライン利用可能
- アプリ起動時にメモリにロード
- アップデート時のみ更新
- Next.jsバックエンドは`lessonId`やレベル、順序などのメタデータのみを保持し、本文コンテンツなどの詳細は常にアプリ内JSONを参照する（APIで本文は返さない）
- `xpReward`のような報酬値は管理せず、進捗は完了回数/WPM/Accuracy/Timeの統計のみで表現する

### 2.2 JSONファイル構造

#### レッスンメタデータ + コンテンツ
```json
{
  "id": "les_beginner_001",
  "title": "基本の子音 ㄱ, ㄴ, ㄷ",
  "level": "beginner",
  "order": 1,
  "description": "韓国語の基本子音3つを学びます。",
  "content": {
    "sections": [
      {
        "type": "character_drill",
        "title": "文字を覚えよう",
        "items": [
          {
            "text": "ㄱ",
            "meaning": "g/k の音",
            "pronunciation": "ギヨク（기역）",
            "hint": "「ガ行」に似ています"
          },
          {
            "text": "ㄴ",
            "meaning": "n の音",
            "pronunciation": "ニウン（니은）",
            "hint": "「ナ行」です"
          },
          {
            "text": "ㄷ",
            "meaning": "d/t の音",
            "pronunciation": "ディグッ（디귿）",
            "hint": "「ダ行」に似ています"
          }
        ]
      },
      {
        "type": "word_practice",
        "title": "単語を入力しよう",
        "items": [
          {
            "text": "가다",
            "meaning": "行く",
            "pronunciation": "カダ",
            "hint": "ㄱ + ㅏ + ㄷ + ㅏ"
          },
          {
            "text": "나무",
            "meaning": "木",
            "pronunciation": "ナム",
            "hint": "ㄴ + ㅏ + ㅁ + ㅜ"
          },
          {
            "text": "다리",
            "meaning": "橋/脚",
            "pronunciation": "タリ",
            "hint": "ㄷ + ㅏ + ㄹ + ㅣ"
          }
        ]
      },
      {
        "type": "sentence_practice",
        "title": "短文を入力しよう",
        "items": [
          {
            "text": "나는 간다",
            "meaning": "私は行く",
            "pronunciation": "ナヌン カンダ",
            "hint": "나는（私は）+ 간다（行く）"
          }
        ]
      }
    ]
  }
}
```

#### フィールド説明

| フィールド | 型 | 説明 |
|-----------|-----|------|
| `id` | String | レッスンの一意な識別子 |
| `title` | String | レッスンのタイトル（日本語） |
| `level` | Enum | `beginner` / `intermediate` / `advanced` |
| `order` | Int | レベル内での順序（1始まり） |
| `description` | String | レッスンの説明文 |
| `content.sections` | Array | セクションの配列 |

#### セクションタイプ

##### 1. `character_drill` - 文字ドリル
個別の文字（子音・母音）を学習
```json
{
  "type": "character_drill",
  "title": "文字を覚えよう",
  "items": [
    {
      "text": "ㄱ",
      "meaning": "g/k の音",
      "pronunciation": "ギヨク（기역）",
      "hint": "「ガ行」に似ています"
    }
  ]
}
```

##### 2. `word_practice` - 単語練習
完全な単語を入力
```json
{
  "type": "word_practice",
  "title": "単語を入力しよう",
  "items": [
    {
      "text": "한국",
      "meaning": "韓国",
      "pronunciation": "ハングク",
      "hint": "한（韓）+ 국（国）"
    }
  ]
}
```

##### 3. `sentence_practice` - 短文練習
文章やフレーズを入力
```json
{
  "type": "sentence_practice",
  "title": "短文を入力しよう",
  "items": [
    {
      "text": "안녕하세요",
      "meaning": "こんにちは",
      "pronunciation": "アンニョンハセヨ",
      "hint": "韓国語の基本の挨拶"
    }
  ]
}
```

### 2.3 レッスンインデックスファイル

全レッスンの一覧を管理する `lessons_index.json`
```json
{
  "version": "1.0.0",
  "lastUpdated": "2024-03-15T00:00:00Z",
  "levels": {
    "beginner": {
      "totalLessons": 20,
      "lessons": [
        {
          "id": "les_beginner_001",
          "order": 1,
          "title": "基本の子音 ㄱ, ㄴ, ㄷ",
          "file": "beginner_001.json",
          "isLocked": false
        },
        {
          "id": "les_beginner_002",
          "order": 2,
          "title": "基本の母音 ㅏ, ㅓ, ㅗ, ㅜ",
          "file": "beginner_002.json",
          "isLocked": false
        }
      ]
    },
    "intermediate": {
      "totalLessons": 20,
      "lessons": [...]
    },
    "advanced": {
      "totalLessons": 20,
      "lessons": [...]
    }
  }
}
```

---

## 3. ホーム画面（レーン選択）

### 3.1 画面構成
```
┌─────────────────────────────────┐
│  👤 ユーザー名                   │  ← ヘッダー
│  🔥 連続3日  ⚡ 正解率 92%       │  ← 統計サマリー
├─────────────────────────────────┤
│  📚 初級レーン                   │  ← アコーディオン（開閉可能）
│    ▼ レッスンを選択              │
│    ├─ レッスン1: 基本の子音      │
│    │   📊 80%完了                │
│    ├─ レッスン2: 基本の母音      │
│    │   📊 0%未完                 │
│    └─ ...                       │
├─────────────────────────────────┤
│  📗 中級レーン                   │
│    ▶ レッスンを選択（折りたたみ）│
├─────────────────────────────────┤
│  📕 上級レーン                   │
│    ▶ レッスンを選択              │
├─────────────────────────────────┤
│  ⚡ クイックアクション           │
│    [弱点強化] [カスタム練習]     │
 └─────────────────────────────────┘
```

- **ヒーローカード**: 週の完了レッスン数と総学習時間をまとめたカードを表示し、現状の成果を一目で把握できるようにする。
- **統計サマリー**: 正解率 / WPM / 連続日数を3枚のカードで表示（`LessonStatsSummary` を使用）。
- **クイックアクション**: 「弱点強化」（未完了レッスンの中で最も早いものを即時スタート）と「カスタム練習」（ティーザー & 通知）を2枚のカードで配置。
- **レーンごとのアコーディオン**: 各レベルのレッスンをカードリストで表示し、完了率（0/25/50/75/100%）とロック状態、進捗バーを同時に表示する。

### 3.2 データ取得
1. **アプリ起動時**:
   - `assets/lessons/lessons_index.json` を読み込み
   - ユーザーの進捗状況をバックエンドから取得（`GET /api/lessons/stats?range=all`）
   - ローカルストレージから前回のプログレスをキャッシュ取得

2. **表示情報**:
   - レッスン一覧（レベル別）
   - 各レッスンの完了率（0%、25%、50%、75%、100%）
   - ロック状態（前のレッスンが未完了の場合）

3. **ユーザー統計**:
   - 連続学習日数（streak days）
   - 平均正解率（accuracy average）
   - 平均WPM（words per minute）
   - 総学習時間
   - サーバーから取得した統計値はローカルキャッシュとマージし、即座に UI に反映する

### 3.3 レーン選択の動作
- 初級/中級/上級のアコーディオンをタップして展開
- 展開すると、そのレベルのレッスン一覧が表示される
- レッスンをタップすると、レッスン詳細画面へ遷移

### 3.4 完了率とロック判定
- 完了率は 25% 刻みで増加する。レッスン完了のたびに `+25%`（最大100%）し、`SharedPreferences` に保存。
- ベスト記録（WPM / Accuracy / 最終実施日時）も同じキャッシュに保持する。
- 同一レベル内で直前のレッスンが 100% になっていない場合、次のレッスンはロック表示とする（タップ時はトーストで案内）。
- `lessons_index.json` の `isLocked` フラグが `true` の場合も強制的にロックされる（今後のイベント用）。

---

## 4. レッスン選択

### 4.1 レッスン詳細画面
```
┌─────────────────────────────────┐
│  ← レッスン1: 基本の子音         │  ← ヘッダー
├─────────────────────────────────┤
│                                 │
│  📖 レッスン概要                │
│  韓国語の基本子音3つ（ㄱ, ㄴ, ㄷ）│
│  を学びます。                   │
│                                 │
│  📊 完了率: 80%                 │
│                                 │
│  ┌───────────────────────┐     │
│  │  📝 学習内容              │     │
│  │  • 文字ドリル（3文字）     │     │
│  │  • 単語練習（5単語）       │     │
│  │  • 短文練習（2文）        │     │
│  └───────────────────────┘     │
│                                 │
│  ┌───────────────────────┐     │
│  │  🏅 あなたの最高記録      │     │
│  │  WPM: 210 | 正解率: 95%   │     │
│  │  前回: 2024-03-10         │     │
│  └───────────────────────┘     │
│                                 │
│  [開始する]                     │  ← 大きなボタン
│                                 │
└─────────────────────────────────┘
```

- 「あなたの最高記録」カードには、ベストWPM/Accuracy/前回日時を表示し、記録がない場合は「初挑戦を促すコピー」を表示する。
- 前のレッスンが未完了の場合は黄色のバナーで「ロック中」を表示し、開始ボタンを無効化する。

### 4.2 開始ボタンの動作
1. レッスンJSONファイルをロード（`assets/lessons/{file}`）
2. TypingSessionProviderを初期化
3. タイピング画面へ遷移（Navigator.push）

---

## 5. タイピング画面の詳細

### 5.1 画面レイアウト
```
┌─────────────────────────────────┐
│  ← レッスン1   ⚙️               │  ← ヘッダー（戻る、設定）
│  進捗: ███████░░░ 70% (7/10)   │  ← プログレスバー
├─────────────────────────────────┤
│  ⏱ 00:45.2                      │  ← タイマー
├─────────────────────────────────┤
│                                 │
│      問題: 한국                 │  ← 問題文（28px、Bold）
│      (韓国)                     │  ← 意味（16px、Gray）
│                                 │
│      入力: 한_                  │  ← 入力中（28px、カーソル）
│            ✓✗                   │  ← 正誤インジケーター
│                                 │
│      組み立て中: ㅎ + ㅏ + ㄴ     │  ← Jamo組み立て状態
│                                 │
├─────────────────────────────────┤
│  [カスタムキーボード]            │  ← 韓国語キーボード
│  (詳細は 4_タイピングキーボード.md)│
│                                 │
└─────────────────────────────────┘
```

### 5.2 画面要素の詳細

#### プログレスバー
- 現在の進捗を視覚的に表示
- `(完了したアイテム数) / (総アイテム数)`
- アニメーション: スムーズに増加（200ms）

#### タイマー
- フォーマット: `MM:SS.d` (分:秒.1桁)
- 小数点1桁まで表示（0.1秒精度）
- レッスン開始時にスタート、完了時に停止
- 途中で戻るボタンを押しても記録（中断として扱う）

#### 問題表示エリア
- **問題文**: 入力すべき韓国語テキスト
  - フォント: 28px、Bold
  - 色: Black（ライトモード）/ White（ダークモード）
- **意味**: 日本語訳
  - フォント: 16px、Regular
  - 色: Gray（#757575）
  - 括弧付き: `(意味)`
- **発音**: オプションで表示可能
  - 設定でON/OFFを切り替え

#### 入力エリア
- **入力済み文字**: 緑色（正解）/ 赤色（不正解）
- **現在入力中の文字**: アンダーライン + カーソル
- **未入力部分**: アンダースコア `_` で表示

#### 組み立て中の文字表示
```
組み立て中: ㅎ + ㅏ + ㄴ → 한
```
- 現在入力中のJamo（字母）を視覚化
- リアルタイムで更新
- 初心者向けの学習補助

#### 正誤インジケーター
- ✓ 緑色: 正解
- ✗ 赤色: 不正解
- 各文字の下に表示
- アニメーション:
  - 正解: パルス（拡大→縮小）
  - 不正解: 横揺れ（shake）

### 5.3 ヒント機能

#### ヒント表示の動作
`docs/4_タイピングキーボード.md` に詳細がありますが、概要は以下の通り：

- **デフォルト: ON**（設定で変更可能）
- **次に押すべきキー**を黄色（#FFD700）でハイライト
- **濃音の場合**: Shiftキーと子音キーの両方をハイライト
- **キーをタップ**すると、次のキーが自動的にハイライト
- 不正解のキーをタップしてもハイライトは変わらない

#### ヒント機能のON/OFF
- ヘッダーの⚙️設定アイコンをタップ
- クイック設定メニューが表示
  - ✓ ヒント機能（ON/OFF トグル）
  - ✓ キー音
  - ✓ 振動
- 設定は即座に反映され、SharedPreferencesに保存

---

## 6. 完了画面とデータ送信

### 6.1 完了画面のレイアウト
```
┌─────────────────────────────────┐
│         🎉 완성! 🎉             │  ← 花吹雪アニメーション
│                                 │
│      レッスン1 完了！           │  ← レッスンタイトル
│                                 │
│  ┌───────────────────────┐     │
│  │  📊 あなたの結果        │     │  ← カウントアップアニメーション
│  │                        │     │
│  │  スコア: 92点          │     │
│  │  正解率: 95%           │     │
│  │  スピード: 48文字/分   │     │
│  │  所要時間: 5分32秒     │     │
│  │                        │     │
│  └───────────────────────┘     │
│                                 │
│  ┌───────────────────────┐     │
│  │  🎯 詳細統計            │     │
│  │                        │     │
│  │  正解: 38文字          │     │
│  │  不正解: 2文字         │     │
│  │  総文字数: 40文字      │     │
│  │                        │     │
│  └───────────────────────┘     │
│                                 │
│  ┌───────────────────────┐     │
│  │  💡 弱点文字            │     │
│  │  ㅈ, ㅊ, ㅉ             │     │  ← 間違えた文字
│  │  復習をおすすめします   │     │
│  └───────────────────────┘     │
│                                 │
│  [次のレッスン]  [ホームに戻る]  │  ← アクションボタン
│  [もう一度挑戦]                 │
│                                 │
└─────────────────────────────────┘
```

### 6.2 スコア計算

#### WPM（Words Per Minute）の計算
```dart
int calculateWPM(int totalCharacters, int timeSpentMs) {
  // 韓国語では1文字を「1単語」として扱う
  // （英語のようにスペース区切りではない）
  double minutes = timeSpentMs / 60000.0;
  double wpm = totalCharacters / minutes;
  return wpm.round();
}

// 例: 40文字を5分32秒（332000ms）で入力
// WPM = 40 / (332000 / 60000) = 40 / 5.533 = 7.23 ≈ 7文字/分
// ※ 実際には「正解文字数」のみをカウント
```

#### 正解率（Accuracy）の計算
```dart
double calculateAccuracy(int correctCount, int totalCount) {
  if (totalCount == 0) return 0.0;
  return correctCount / totalCount;
}

// 例: 40文字中38文字正解
// Accuracy = 38 / 40 = 0.95 = 95%
```

#### スコアポイントの計算
```dart
int calculateScore(int wpm, double accuracy) {
  // WPMスコア + 正解率ボーナス
  int wpmScore = wpm * 10;  // WPM × 10
  int accuracyBonus = (accuracy * 100).round();  // 正解率 × 100

  return wpmScore + accuracyBonus;
}

// 例: WPM=48, Accuracy=95%
// Score = (48 * 10) + (0.95 * 100) = 480 + 95 = 575点
```

### 6.3 弱点文字の分析

```dart
Map<String, int> analyzeWeakCharacters(List<InputRecord> records) {
  Map<String, int> errorCount = {};

  for (var record in records) {
    if (!record.isCorrect) {
      String char = record.expectedChar;
      errorCount[char] = (errorCount[char] ?? 0) + 1;
    }
  }

  // エラー回数でソート（降順）
  var sorted = errorCount.entries.toList()
    ..sort((a, b) => b.value.compareTo(a.value));

  // 上位3つを返す
  return Map.fromEntries(sorted.take(3));
}

// 例: { 'ㅈ': 3, 'ㅊ': 2, 'ㅉ': 1 }
```

### 6.4 バックエンドへのデータ送信

#### POST /api/lessons/complete

```dart
Future<void> submitLessonCompletion({
  required String lessonId,
  required int wpm,
  required double accuracy,
  required int timeSpentMs,
  required String device,
  required String mode,
}) async {
  final dio = Dio();
  final token = await getAccessToken();

  try {
    final response = await dio.post(
      'https://api.example.com/api/lessons/complete',
      data: {
        'lessonId': lessonId,
        'wpm': wpm,
        'accuracy': accuracy,
        'timeSpent': timeSpentMs,
        'device': device,  // 'ios' | 'android' | 'web'（省略可、デフォルトは'ios'）
        'mode': 'standard',  // 現在は 'standard' のみをサポート（省略可、デフォルトは'standard'）
      },
      options: Options(
        headers: {
          'Authorization': 'Bearer $token',
          'Content-Type': 'application/json',
        },
      ),
    );

    if (response.statusCode == 201) {
      // 成功: LessonCompletion オブジェクトを取得
      print('Lesson completion recorded: ${response.data}');
    }
  } on DioException catch (e) {
    // エラーハンドリング
    print('Failed to submit completion: $e');
    rethrow;
  }
}
```

> 補足: 同一レッスンの完了データは連続送信を許可し、クールダウンは設けない。再挑戦 → 即送信というループが成立することを前提に、UIとバックエンドの双方で制限を入れない。

---

## 7. 状態管理（Riverpod設計）

### 7.1 必要なプロバイダー

#### 1. LessonDataProvider - レッスンデータのロード

```dart
@riverpod
class LessonData extends _$LessonData {
  @override
  FutureOr<Map<String, Lesson>> build() async {
    // assets/lessons/lessons_index.json を読み込み
    final indexJson = await rootBundle.loadString('assets/lessons/lessons_index.json');
    final index = jsonDecode(indexJson);

    // 各レッスンファイルをロード
    Map<String, Lesson> lessons = {};
    for (var level in ['beginner', 'intermediate', 'advanced']) {
      for (var lessonMeta in index['levels'][level]['lessons']) {
        final lessonJson = await rootBundle.loadString(
          'assets/lessons/${lessonMeta['file']}',
        );
        final lesson = Lesson.fromJson(jsonDecode(lessonJson));
        lessons[lesson.id] = lesson;
      }
    }

    return lessons;
  }

  Lesson? getLesson(String id) {
    return state.value?[id];
  }

  List<Lesson> getLessonsByLevel(String level) {
    return state.value?.values
      .where((l) => l.level == level)
      .toList()
      .sorted((a, b) => a.order.compareTo(b.order)) ?? [];
  }
}
```

#### 2. TypingSessionProvider - タイピングセッションの状態管理

```dart
@riverpod
class TypingSession extends _$TypingSession {
  Timer? _timer;

  @override
  TypingSessionState build(String lessonId) {
    final lesson = ref.watch(lessonDataProvider).value?[lessonId];
    if (lesson == null) {
      throw Exception('Lesson not found: $lessonId');
    }

    // 初期状態
    return TypingSessionState(
      lessonId: lessonId,
      lesson: lesson,
      currentSectionIndex: 0,
      currentItemIndex: 0,
      inputBuffer: '',
      currentJamo: JamoState.empty(),
      elapsedMs: 0,
      records: [],
      isRunning: false,
    );
  }

  void start() {
    state = state.copyWith(isRunning: true);
    _timer = Timer.periodic(Duration(milliseconds: 100), (_) {
      state = state.copyWith(elapsedMs: state.elapsedMs + 100);
    });
  }

  void pause() {
    _timer?.cancel();
    state = state.copyWith(isRunning: false);
  }

  void processKeyInput(String key) {
    // キー入力を処理
    // 1. Jamoの種類を判定（子音/母音）
    // 2. 現在の状態に応じて組み立て
    // 3. 正解と比較
    // 4. レコードに追加

    final isCorrect = validateInput(state.inputBuffer + key);
    state = state.copyWith(
      inputBuffer: state.inputBuffer + key,
      records: [...state.records, InputRecord(key: key, isCorrect: isCorrect)],
    );

    // 次のアイテムへ進む
    if (isItemComplete()) {
      moveToNextItem();
    }
  }

  bool isItemComplete() {
    final currentItem = getCurrentItem();
    return state.inputBuffer == currentItem.text;
  }

  void moveToNextItem() {
    // 次のアイテムへ
    if (state.currentItemIndex < getCurrentSection().items.length - 1) {
      state = state.copyWith(
        currentItemIndex: state.currentItemIndex + 1,
        inputBuffer: '',
        currentJamo: JamoState.empty(),
      );
    } else if (state.currentSectionIndex < state.lesson.content.sections.length - 1) {
      // 次のセクションへ
      state = state.copyWith(
        currentSectionIndex: state.currentSectionIndex + 1,
        currentItemIndex: 0,
        inputBuffer: '',
        currentJamo: JamoState.empty(),
      );
    } else {
      // レッスン完了
      complete();
    }
  }

  void complete() {
    _timer?.cancel();
    state = state.copyWith(isRunning: false);
    // 完了画面へ遷移
  }

  @override
  void dispose() {
    _timer?.cancel();
    super.dispose();
  }
}
```

#### 3. TypingStatsProvider - 統計計算

```dart
@riverpod
class TypingStats extends _$TypingStats {
  @override
  TypingStatsData build(String sessionId) {
    final session = ref.watch(typingSessionProvider(sessionId));

    // 統計を計算
    final correctCount = session.records.where((r) => r.isCorrect).length;
    final totalCount = session.records.length;
    final accuracy = totalCount > 0 ? correctCount / totalCount : 0.0;
    final wpm = calculateWPM(correctCount, session.elapsedMs);

    return TypingStatsData(
      correctCount: correctCount,
      incorrectCount: totalCount - correctCount,
      totalCount: totalCount,
      accuracy: accuracy,
      wpm: wpm,
      elapsedMs: session.elapsedMs,
    );
  }
}
```

#### 4. UserProgressProvider - ユーザーの進捗管理

```dart
@riverpod
class UserProgress extends _$UserProgress {
  static const _cacheKey = 'lesson_progress_cache_v1';

  @override
  FutureOr<Map<String, LessonProgress>> build() async {
    final prefs = await SharedPreferences.getInstance();
    final cached = prefs.getString(_cacheKey);
    final local = cached == null ? <String, LessonProgress>{} : parseProgress(cached);

    // バックグラウンドで最新統計を取得し、キャッシュを更新
    unawaited(_syncFromServer(local));

    return local;
  }

  Future<void> markCompleted(String lessonId, {required int wpm, required double accuracy}) async {
    final current = state.value ?? const <String, LessonProgress>{};
    final existing = current[lessonId];
    final updatedRate = _nextCompletionRate(existing?.completionRate ?? 0);
    final updated = LessonProgress(
      lessonId: lessonId,
      completionRate: updatedRate,
      lastCompletedAt: DateTime.now(),
      bestWpm: existing?.bestWpm == null ? wpm : max(existing!.bestWpm!, wpm),
      bestAccuracy: existing?.bestAccuracy == null
          ? accuracy
          : max(existing!.bestAccuracy!, accuracy),
    );

    final nextState = {...current, lessonId: updated};
    state = AsyncData(nextState);
    final prefs = await SharedPreferences.getInstance();
    final payload = nextState.map((key, value) => MapEntry(key, value.toJson()));
    await prefs.setString(_cacheKey, jsonEncode(payload));
  }

  int _nextCompletionRate(int current) {
    if (current >= 100) return 100;
    if (current <= 0) return 25;
    final steps = (current / 25).floor();
    return ((steps + 1) * 25).clamp(0, 100);
  }

  Future<void> _syncFromServer(Map<String, LessonProgress> local) async {
    final dio = ref.watch(dioProvider);
    final response = await dio.get('/api/lessons/stats?range=all');
    // TODO: バックエンドが per-lesson 進捗を返すようになったらマージ処理を追加
  }
}
```

### 7.2 状態クラスの定義

```dart
@freezed
class TypingSessionState with _$TypingSessionState {
  const factory TypingSessionState({
    required String lessonId,
    required Lesson lesson,
    required int currentSectionIndex,
    required int currentItemIndex,
    required String inputBuffer,
    required JamoState currentJamo,
    required int elapsedMs,
    required List<InputRecord> records,
    required bool isRunning,
  }) = _TypingSessionState;
}

@freezed
class JamoState with _$JamoState {
  const factory JamoState({
    String? initial,   // 初声
    String? medial,    // 中声
    String? final_,    // 終声
  }) = _JamoState;

  factory JamoState.empty() => JamoState(
    initial: null,
    medial: null,
    final_: null,
  );
}

@freezed
class InputRecord with _$InputRecord {
  const factory InputRecord({
    required String key,
    required bool isCorrect,
    required DateTime timestamp,
    String? expectedChar,
  }) = _InputRecord;
}
```

---

## 8. データフロー

### 8.1 レッスン開始フロー

```
[ホーム画面]
    ↓ アプリ起動時
LessonDataProvider.build()
    ↓ assets読み込み
lessons_index.json → 各レッスンJSON → メモリにキャッシュ
    ↓
[レッスン一覧表示]
    ↓ レッスン選択
[レッスン詳細画面]
    ↓ 「開始」ボタンタップ
TypingSessionProvider.build(lessonId)
    ↓ レッスンデータ取得
[タイピング画面]
    ↓
TypingSession.start()
    ↓ タイマー開始
[入力待機]
```

### 8.2 入力処理フロー

```
[ユーザーがキーをタップ]
    ↓
TypingSession.processKeyInput(key)
    ↓
1. キーの種類を判定（子音/母音/スペース/削除）
    ↓
2. 現在のJamo状態に応じて処理
   - 子音: 初声 or 終声 or 新文字開始
   - 母音: 中声として追加
   - 削除: 1文字削除（Jamo単位）
    ↓
3. Unicodeに変換（composeHangul）
    ↓
4. 正解と比較（NFC正規化）
    ↓
5. 結果を記録（InputRecord）
    ↓
6. UI更新（state変更 → rebuild）
    ↓
7. ヒント更新（次のキーをハイライト）
    ↓
8. 完了チェック
   - アイテム完了 → 次のアイテムへ
   - セクション完了 → 次のセクションへ
   - レッスン完了 → 完了画面へ
```

### 8.3 完了処理フロー

```
[最後のアイテムを入力完了]
    ↓
TypingSession.complete()
    ↓ タイマー停止
TypingStats.build() で統計計算
    ↓
[完了画面へ遷移]
    ↓ 結果表示（アニメーション）
    ↓
バックエンドへ送信（POST /api/lessons/complete）
    ↓
成功: LessonCompletion レコード取得
    ↓
UserProgressProvider.updateProgress()
    ↓ 進捗更新
[次のアクション選択]
```

---

## 9. エラーハンドリング

### 9.1 レッスンデータロード失敗

```dart
@riverpod
class LessonData extends _$LessonData {
  @override
  FutureOr<Map<String, Lesson>> build() async {
    try {
      // レッスンデータをロード
      return await loadLessons();
    } catch (e, stack) {
      // エラーログ
      logger.error('Failed to load lessons', error: e, stackTrace: stack);

      // ローカルキャッシュから復元を試みる
      final prefs = await SharedPreferences.getInstance();
      final cached = prefs.getString('lessons_cache');
      if (cached != null) {
        logger.info('Restored lessons from cache');
        return parseLessonsFromJson(cached);
      }

      // キャッシュもない場合はエラーを投げる
      throw LessonLoadException(
        'レッスンデータの読み込みに失敗しました。アプリを再起動してください。',
      );
    }
  }
}
```

**UI側の処理**:
```dart
Widget build(BuildContext context, WidgetRef ref) {
  final lessonsAsync = ref.watch(lessonDataProvider);

  return lessonsAsync.when(
    data: (lessons) => LessonListView(lessons: lessons),
    loading: () => Center(child: CircularProgressIndicator()),
    error: (error, stack) => ErrorView(
      message: error.toString(),
      onRetry: () => ref.invalidate(lessonDataProvider),
    ),
  );
}
```

### 9.2 API送信失敗

```dart
Future<void> submitCompletion(TypingSessionState session) async {
  try {
    await ref.read(lessonRepositoryProvider).submitCompletion(
      lessonId: session.lessonId,
      wpm: calculateWPM(session),
      accuracy: calculateAccuracy(session),
      timeSpent: session.elapsedMs,
    );
  } on DioException catch (e) {
    if (e.type == DioExceptionType.connectionTimeout) {
      // タイムアウト: ローカルに保存して後でリトライ
      await saveToLocalQueue(session);
      showSnackBar('オフラインのため、後で自動送信します。');
    } else {
      // その他のエラー
      logger.error('Failed to submit completion', error: e);
      showSnackBar('送信に失敗しました。もう一度お試しください。');
    }
  }
}
```

### 9.3 ネットワークエラー時の処理

**オフラインキュー**:
```dart
@riverpod
class OfflineQueue extends _$OfflineQueue {
  @override
  List<PendingCompletion> build() {
    // SharedPreferencesから未送信データをロード
    return loadPendingCompletions();
  }

  void add(PendingCompletion completion) {
    state = [...state, completion];
    savePendingCompletions(state);
  }

  Future<void> processQueue() async {
    for (var completion in state) {
      try {
        await submitCompletion(completion);
        // 成功したら削除
        state = state.where((c) => c.id != completion.id).toList();
      } catch (e) {
        // 失敗したらスキップ（次回リトライ）
        logger.warning('Failed to process queued completion', error: e);
      }
    }
    savePendingCompletions(state);
  }
}
```

**アプリ起動時に自動送信**:
```dart
void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  final container = ProviderContainer();

  // ネットワーク接続を確認
  final connectivity = await Connectivity().checkConnectivity();
  if (connectivity != ConnectivityResult.none) {
    // オンラインならキューを処理
    container.read(offlineQueueProvider.notifier).processQueue();
  }

  runApp(UncontrolledProviderScope(container: container, child: MyApp()));
}
```

### 9.4 予期しないエラー

**グローバルエラーハンドラ**:
```dart
void main() {
  FlutterError.onError = (details) {
    logger.error('Flutter error', error: details.exception, stackTrace: details.stack);
    // Sentryなどのエラートラッキングサービスに送信
  };

  PlatformDispatcher.instance.onError = (error, stack) {
    logger.error('Platform error', error: error, stackTrace: stack);
    return true;
  };

  runApp(MyApp());
}
```

---

## 10. パフォーマンス最適化

### 10.1 レッスンデータの遅延ロード

全レッスンを一度にロードせず、必要に応じてロードする：

```dart
@riverpod
class LessonData extends _$LessonData {
  final Map<String, Lesson> _cache = {};

  @override
  FutureOr<Map<String, Lesson>> build() async {
    // 初回はインデックスのみロード
    final indexJson = await rootBundle.loadString('assets/lessons/lessons_index.json');
    return {}; // 空のマップを返す
  }

  Future<Lesson> loadLesson(String lessonId) async {
    // キャッシュにあれば返す
    if (_cache.containsKey(lessonId)) {
      return _cache[lessonId]!;
    }

    // ファイルからロード
    final lessonJson = await rootBundle.loadString('assets/lessons/$lessonId.json');
    final lesson = Lesson.fromJson(jsonDecode(lessonJson));
    _cache[lessonId] = lesson;

    return lesson;
  }
}
```

### 10.2 入力処理の最適化

頻繁に呼ばれる入力処理は効率化：

```dart
// 事前に計算したルックアップテーブルを使用
class JamoConverter {
  static const Map<String, int> initialIndex = {
    'ㄱ': 0, 'ㄲ': 1, 'ㄴ': 2, 'ㄷ': 3, 'ㄸ': 4,
    // ... 全19文字
  };

  static const Map<String, int> medialIndex = {
    'ㅏ': 0, 'ㅐ': 1, 'ㅑ': 2, 'ㅒ': 3, 'ㅓ': 4,
    // ... 全21文字
  };

  static int composeHangul(String initial, String medial, String? final_) {
    final i = initialIndex[initial]!;
    final m = medialIndex[medial]!;
    final f = final_ != null ? finalIndex[final_]! : 0;

    return 0xAC00 + (i * 588) + (m * 28) + f;
  }
}
```

### 10.3 UI更新の最適化

不要な再描画を避ける：

```dart
// 入力エリアのみを部分的に更新
Consumer(
  builder: (context, ref, child) {
    final session = ref.watch(typingSessionProvider(lessonId)
      .select((s) => s.inputBuffer));  // inputBufferのみを監視

    return Text(session);
  },
)

// キーボードは別のConsumer
Consumer(
  builder: (context, ref, child) {
    final highlightedKeys = ref.watch(typingSessionProvider(lessonId)
      .select((s) => s.highlightedKeys));  // highlightedKeysのみを監視

    return KeyboardView(highlightedKeys: highlightedKeys);
  },
)
```

---

## 11. 今後の拡張可能性

### 11.1 音声発音機能
- Text-to-Speech APIを利用
- 単語ごとに発音を再生
- 設定でON/OFF可能

### 11.2 カスタムレッスン
- ユーザーが自分で練習したい単語を登録
- フラッシュカードのように繰り返し練習
- 弱点文字を集中的に練習

### 11.3 ソーシャル機能との連携
- レッスン完了を投稿としてシェア
- 友達と進捗を競う
- レッスン完了時のスクリーンショット共有

---

## 付録: 実装チェックリスト

### Phase 1: データ層
- [ ] レッスンJSONスキーマの確定
- [ ] サンプルレッスンデータの作成（初級10個）
- [ ] LessonDataProviderの実装
- [ ] UserProgressProviderの実装

### Phase 2: 入力ロジック
- [ ] Jamo組み立てアルゴリズムの実装
- [ ] Unicode変換関数の実装
- [ ] 正解判定ロジックの実装
- [ ] 濃音入力の実装

### Phase 3: UI実装
- [ ] タイピング画面のレイアウト
- [ ] キーボードの統合
- [ ] ヒント機能の実装
- [ ] タイマーの実装
- [ ] プログレスバーの実装

### Phase 4: 完了処理
- [ ] スコア計算ロジックの実装
- [ ] 完了画面のUI
- [ ] バックエンドAPI送信の実装

### Phase 5: エラーハンドリング
- [ ] オフラインキューの実装
- [ ] リトライロジックの実装
- [ ] エラー表示UIの実装

### Phase 6: 最適化・テスト
- [ ] パフォーマンス測定
- [ ] 遅延ロードの実装
- [ ] ユニットテストの作成
- [ ] 統合テストの作成

---

以上で、タイピング機能の詳細仕様書は完了です。
