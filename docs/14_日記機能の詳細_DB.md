# 日記機能 - DB設計

> **Note**: このドキュメントは日記機能のDB設計を記載しています。
> 機能仕様は [機能仕様](./14_日記機能の詳細_機能.md) を、
> API設計は [API設計](./14_日記機能の詳細_API.md) を、
> UI/UX設計は [UI/UX設計](./14_日記機能の詳細_UI.md) を参照してください。

---

## データモデル設計

### 既存モデル（実装済み）

#### User（拡張が必要）
```prisma
model User {
  id              String    @id @default(cuid())
  auth0UserId     String    @unique
  username        String    @unique
  displayName     String
  email           String    @unique
  profileImageUrl String?
  bio             String?
  followersCount  Int       @default(0)
  followingCount  Int       @default(0)
  postsCount      Int       @default(0)
  settings        Json?     // 通知設定、postDefaultVisibilityを格納
  fcmToken        String?   // Firebase Cloud Messaging トークン
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // リレーション
  posts                    Post[]            @relation("UserPosts")  // 投稿（通常の投稿 + Quoteリポスト）
  comments                 Comment[]
  likes                    Like[]
  commentLikes             CommentLike[]
  following                Follow[]          @relation("Following")
  followers                Follow[]          @relation("Followers")
  reposts                  Repost[]          // 通常のリポスト（コメントなし）
  bookmarks                Bookmark[]
  receivedNotifications    Notification[]    @relation("ReceivedNotifications")
  sentNotifications        Notification[]    @relation("SentNotifications")
  reports                  Report[]          @relation("Reporter")
  blockingUsers            Block[]           @relation("Blocking")  // 自分がブロックしたユーザー
  blockedByUsers           Block[]           @relation("BlockedBy") // 自分をブロックしているユーザー
}
```

#### Post（拡張が必要）
```prisma
model Post {
  id            String    @id @default(cuid())
  content       String    // 最大280文字
  imageUrls     String[]  // 最大4枚
  tags          String[]  @default([])
  visibility    String    @default("public") // public, followers, private
  userId        String
  quotedPostId  String?   // ← 追加: Quoteリポストの場合、元の投稿のID
  likesCount    Int       @default(0)
  commentsCount Int       @default(0)
  repostsCount  Int       @default(0)
  quotesCount   Int       @default(0)      // ← 追加: この投稿を引用したQuoteリポストの数
  isEdited      Boolean   @default(false)
  editedAt      DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // リレーション
  user          User      @relation("UserPosts", fields: [userId], references: [id])
  quotedPost    Post?     @relation("QuotedPosts", fields: [quotedPostId], references: [id])
  quotingPosts  Post[]    @relation("QuotedPosts") // この投稿を引用しているQuoteリポスト
  comments      Comment[]
  likes         Like[]
  reposts       Repost[]  // 通常のリポスト（コメントなし）
  bookmarks     Bookmark[]

  @@index([userId])
  @@index([quotedPostId])
  @@index([createdAt])
}
```

**Quoteリポストの判定**:
- `quotedPostId` が null でない場合、その投稿は Quoteリポスト
- `quotedPostId` が null の場合、通常の投稿

#### Comment（実装済み）
```prisma
model Comment {
  id        String   @id @default(cuid())
  content   String   // 最大280文字（アプリケーション層でバリデーション）
  postId    String
  userId    String
  createdAt DateTime @default(now())
  // リレーション
  post      Post     @relation(fields: [postId], references: [id])
  user      User     @relation(fields: [userId], references: [id])
}
```

#### Like（実装済み）
```prisma
model Like {
  id        String   @id @default(cuid())
  postId    String
  userId    String
  createdAt DateTime @default(now())
  // リレーション
  post      Post     @relation(fields: [postId], references: [id])
  user      User     @relation(fields: [userId], references: [id])
  @@unique([postId, userId])
}
```

#### Follow（実装済み）
```prisma
model Follow {
  id          String   @id @default(cuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())
  // リレーション
  follower    User     @relation("Following", fields: [followerId], references: [id])
  following   User     @relation("Followers", fields: [followingId], references: [id])
  @@unique([followerId, followingId])
}
```

### 追加が必要なモデル

#### 1. Repost（通常のリポスト機能）
```prisma
model Repost {
  id              String   @id @default(cuid())
  userId          String   // リポストしたユーザー
  originalPostId  String   // 元の投稿
  createdAt       DateTime @default(now())

  user            User     @relation(fields: [userId], references: [id])
  originalPost    Post     @relation(fields: [originalPostId], references: [id])

  @@unique([userId, originalPostId])
  @@index([userId])
  @@index([originalPostId])
}
```

**注意**:
- **通常のリポスト**（コメントなし）のみを管理
- **Quoteリポスト**（コメント付き）は `Post` モデルで管理（`quotedPostId` を持つ投稿）

#### 2. Bookmark（ブックマーク機能）
```prisma
model Bookmark {
  id        String   @id @default(cuid())
  userId    String
  postId    String
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id])
  post      Post     @relation(fields: [postId], references: [id])

  @@unique([userId, postId])
  @@index([userId])
}
```

#### 3. Notification（通知機能）
```prisma
enum NotificationType {
  LIKE
  COMMENT
  REPOST
  FOLLOW
}

model Notification {
  id          String           @id @default(cuid())
  userId      String           // 通知を受け取るユーザー
  actorId     String           // アクションを起こしたユーザー
  type        NotificationType
  postId      String?          // 関連する投稿（LIKE, COMMENT, REPOSTの場合）
  commentId   String?          // 関連するコメント（COMMENTの場合）
  isRead      Boolean          @default(false)
  createdAt   DateTime         @default(now())

  user        User             @relation("ReceivedNotifications", fields: [userId], references: [id])
  actor       User             @relation("SentNotifications", fields: [actorId], references: [id])

  @@unique([userId, actorId, type, postId, commentId]) // 重複防止
  @@index([userId, isRead])
  @@index([createdAt])
}
```

**重複防止の仕組み**:
- ユニーク制約により、同一ユーザーから同一対象への同じタイプの通知は1つのみ存在
- 例: ユーザーAが投稿Bにいいねした通知は、`(userId, actorId, type=LIKE, postId, commentId=null)` の組み合わせで1つのみ

#### 4. CommentLike（コメントへのいいね）
```prisma
model CommentLike {
  id        String   @id @default(cuid())
  commentId String
  userId    String
  createdAt DateTime @default(now())

  comment   Comment  @relation(fields: [commentId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([commentId, userId])
  @@index([userId])
  @@index([commentId])
}
```

**Commentモデルへの追加が必要なフィールド**:
```prisma
model Comment {
  // ... 既存フィールド
  likesCount Int          @default(0)  // いいねの集計値
  likes      CommentLike[] // いいねのリレーション
}
```

**集計値の管理**:
- `CommentLike` は単純な関連テーブル（M:N）
- いいね数の集計は `Comment.likesCount` で管理
- いいね作成時に `Comment.likesCount` をインクリメント
- いいね削除時に `Comment.likesCount` をデクリメント

### カスケード削除とデータ削除ポリシー

#### 投稿削除時（`DELETE /api/posts/{postId}`）
投稿を削除すると、以下の関連データも **CASCADE 削除** されます：

```prisma
model Post {
  // ...
  comments      Comment[]   @relation(onDelete: Cascade)
  likes         Like[]      @relation(onDelete: Cascade)
  reposts       Repost[]    @relation(onDelete: Cascade)
  bookmarks     Bookmark[]  @relation(onDelete: Cascade)
}
```

**削除される関連データ**:
1. **Comment**: その投稿に対する全てのコメント
2. **Like**: その投稿に対する全てのいいね
3. **Repost**: その投稿に対する全てのリポスト
4. **Bookmark**: その投稿をブックマークしている全てのブックマーク
5. **Notification**: その投稿に関連する全ての通知（いいね、コメント、リポスト通知）

**Quoteリポストへの影響**:
- その投稿を引用している Quoteリポスト（`quotedPostId` を持つ投稿）は削除されない
- Quoteリポスト側では `quotedPost` が null になる
- UI では「この投稿は削除されました」のように表示

**集計値の更新**:
- `User.postsCount` をデクリメント（投稿者の投稿数）
- Quoteリポストをカウントしている場合、`quotesCount` は変更しない（履歴として残す）
- リポストやいいねをしていた他のユーザーの統計は変更しない

#### コメント削除時（`DELETE /api/comments/{commentId}`）
コメントを削除すると、以下の関連データも **CASCADE 削除** されます：

```prisma
model Comment {
  // ...
  likes      CommentLike[] @relation(onDelete: Cascade)
}
```

**削除される関連データ**:
1. **CommentLike**: そのコメントに対する全てのいいね（CASCADE削除）

**削除されない関連データ**:
- **Notification**: そのコメントに関連する通知は削除しない（履歴として保持）
  - UI側で削除されたコメントへのリンクは「このコメントは削除されました」と表示
  - 通知自体は履歴として価値があるため保持する方針

**集計値の更新**:
- `Post.commentsCount` をデクリメント（投稿のコメント数）

#### ユーザー削除時（仮想的、実装は Phase 5 以降）
ユーザーアカウントを削除すると、以下の関連データも **CASCADE 削除** されます：

```prisma
model User {
  // ...
  posts                    Post[]          @relation(onDelete: Cascade)
  comments                 Comment[]       @relation(onDelete: Cascade)
  likes                    Like[]          @relation(onDelete: Cascade)
  commentLikes             CommentLike[]   @relation(onDelete: Cascade)
  following                Follow[]        @relation("Following", onDelete: Cascade)
  followers                Follow[]        @relation("Followers", onDelete: Cascade)
  reposts                  Repost[]        @relation(onDelete: Cascade)
  bookmarks                Bookmark[]      @relation(onDelete: Cascade)
  receivedNotifications    Notification[]  @relation("ReceivedNotifications", onDelete: Cascade)
  sentNotifications        Notification[]  @relation("SentNotifications", onDelete: Cascade)
  reports                  Report[]        @relation("Reporter", onDelete: Cascade)
  blockingUsers            Block[]         @relation("Blocking", onDelete: Cascade)
  blockedByUsers           Block[]         @relation("BlockedBy", onDelete: Cascade)
}
```

**削除される関連データ**: ユーザーに関連する全てのデータ

**注意**: ユーザー削除機能は初期実装には含まれません（Phase 5 以降の実装予定）

#### 画像削除ポリシー

**投稿削除時**:
- Vercel Blob Storage から画像を物理削除する
- `imageUrls` に含まれる全ての画像ファイルを削除
- 削除処理はバックグラウンドで実行（削除失敗してもAPI エラーにしない）

**投稿編集で画像を削除した場合**:
- 削除された画像（`imageUrls` から除外された画像）を Vercel Blob から物理削除
- 例: `["url1", "url2"]` → `["url1"]` に編集した場合、`url2` の画像を削除

**実装方法**:
```typescript
// 投稿削除時
async function deletePost(postId: string) {
  const post = await prisma.post.findUnique({ where: { id: postId } });

  // 投稿を削除（CASCADE で関連データも削除）
  await prisma.post.delete({ where: { id: postId } });

  // 画像を非同期で削除（失敗しても無視）
  if (post?.imageUrls.length > 0) {
    deleteImagesAsync(post.imageUrls).catch(console.error);
  }
}

// 投稿編集時
async function updatePost(postId: string, newImageUrls: string[]) {
  const post = await prisma.post.findUnique({ where: { id: postId } });
  const oldImageUrls = post?.imageUrls || [];

  // 削除された画像を特定
  const deletedImages = oldImageUrls.filter(url => !newImageUrls.includes(url));

  // 投稿を更新
  await prisma.post.update({
    where: { id: postId },
    data: { imageUrls: newImageUrls }
  });

  // 削除された画像を非同期で削除
  if (deletedImages.length > 0) {
    deleteImagesAsync(deletedImages).catch(console.error);
  }
}

// Vercel Blob から画像を削除
async function deleteImagesAsync(imageUrls: string[]) {
  const { del } = await import('@vercel/blob');
  for (const url of imageUrls) {
    try {
      await del(url);
    } catch (error) {
      console.error(`Failed to delete image: ${url}`, error);
    }
  }
}
```

**注意事項**:
- 画像削除は非同期で実行し、失敗してもユーザーには影響を与えない
- 削除失敗した画像は孤立ファイルとなる可能性があるが、ストレージコストは低いため許容

#### 5. Report（報告機能）
```prisma
enum ReportType {
  POST
  COMMENT
  USER
}

enum ReportReason {
  SPAM
  HARASSMENT
  INAPPROPRIATE_CONTENT
  HATE_SPEECH
  OTHER
}

model Report {
  id          String       @id @default(cuid())
  reporterId  String       // 報告したユーザー
  type        ReportType
  targetId    String       // 報告対象のID（postId, commentId, userId）
  reason      ReportReason
  description String?
  status      String       @default("pending") // pending, reviewed, resolved
  createdAt   DateTime     @default(now())

  reporter    User         @relation(fields: [reporterId], references: [id])

  @@index([status])
  @@index([createdAt])
}
```

#### 6. Block（ブロック機能）
```prisma
model Block {
  id         String   @id @default(cuid())
  blockerId  String   // ブロックしたユーザー
  blockedId  String   // ブロックされたユーザー
  createdAt  DateTime @default(now())

  blocker    User     @relation("Blocking", fields: [blockerId], references: [id])
  blocked    User     @relation("BlockedBy", fields: [blockedId], references: [id])

  @@unique([blockerId, blockedId])
  @@index([blockerId])
}
```

---
